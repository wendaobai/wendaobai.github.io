import{_ as s,c as a,o as n,e as l}from"./app.58766e8b.js";const p="/assets/image-20230413101814544-1682298900833.955820dd.png",o="/assets/image-20230413103620394-1682298900833.dfee0970.png",e="/assets/image-20230413103911816-1682298900833.77c6059d.png",t="/assets/image-20230413104023389-1682298900833.839bc4fe.png",c="/assets/image-20230413104236688-1682298900833.218460e3.png",r="/assets/image-20230413105303246-1682298900833.e7e2f81d.png",y="/assets/image-20230413105522514-1682298900833.6b39a455.png",C="/assets/image-20230413111937988-1682299232264.f91f02ea.png",D="/assets/image-20230413112223908-1682299232265.d1a77c8a.png",F="/assets/image-20230413112255465-1682299232265.0b8d5109.png",i="/assets/image-20230413160247747-1682299732049.2f1c932f.png",A="/assets/image-20230413160331381-1682299732050.ccf55b6f.png",S=JSON.parse('{"title":"第一篇 框架设计概览","description":"","frontmatter":{},"headers":[{"level":2,"title":"第 1 章 权衡的艺术","slug":"第-1-章-权衡的艺术","link":"#第-1-章-权衡的艺术","children":[]},{"level":2,"title":"1.1 命令式和声明式","slug":"_1-1-命令式和声明式","link":"#_1-1-命令式和声明式","children":[]},{"level":2,"title":"1.2 性能与可维护性的权衡","slug":"_1-2-性能与可维护性的权衡","link":"#_1-2-性能与可维护性的权衡","children":[]},{"level":2,"title":"1.3 虚拟 DOM 的性能到底如何","slug":"_1-3-虚拟-dom-的性能到底如何","link":"#_1-3-虚拟-dom-的性能到底如何","children":[]},{"level":2,"title":"1.4 运行时和编译时","slug":"_1-4-运行时和编译时","link":"#_1-4-运行时和编译时","children":[]},{"level":2,"title":"1.5 总结","slug":"_1-5-总结","link":"#_1-5-总结","children":[]},{"level":2,"title":"第 2 章 框架设计的核心要素","slug":"第-2-章-框架设计的核心要素","link":"#第-2-章-框架设计的核心要素","children":[]},{"level":2,"title":"2.1 提升用户的开发体验","slug":"_2-1-提升用户的开发体验","link":"#_2-1-提升用户的开发体验","children":[]},{"level":2,"title":"2.2 控制框架代码的体积","slug":"_2-2-控制框架代码的体积","link":"#_2-2-控制框架代码的体积","children":[]},{"level":2,"title":"2.3 框架要做到良好的 Tree-Shaking","slug":"_2-3-框架要做到良好的-tree-shaking","link":"#_2-3-框架要做到良好的-tree-shaking","children":[]},{"level":2,"title":"2.4 框架应该输出怎样的构建产物","slug":"_2-4-框架应该输出怎样的构建产物","link":"#_2-4-框架应该输出怎样的构建产物","children":[]},{"level":2,"title":"2.5 特性开关","slug":"_2-5-特性开关","link":"#_2-5-特性开关","children":[{"level":3,"title":"2.5 特性开关","slug":"_2-5-特性开关-1","link":"#_2-5-特性开关-1","children":[]}]},{"level":2,"title":"2.6 错误处理","slug":"_2-6-错误处理","link":"#_2-6-错误处理","children":[]},{"level":2,"title":"2.7 良好的 TypeScript 类型支持","slug":"_2-7-良好的-typescript-类型支持","link":"#_2-7-良好的-typescript-类型支持","children":[]},{"level":2,"title":"2.8 总结","slug":"_2-8-总结","link":"#_2-8-总结","children":[]}],"relativePath":"前端框架/vue/1.Vue-框架设计要素.md"}'),d={name:"前端框架/vue/1.Vue-框架设计要素.md"},u=l(`<h1 id="第一篇-框架设计概览" tabindex="-1">第一篇 框架设计概览 <a class="header-anchor" href="#第一篇-框架设计概览" aria-hidden="true">#</a></h1><h2 id="第-1-章-权衡的艺术" tabindex="-1"><strong>第 1 章 权衡的艺术</strong> <a class="header-anchor" href="#第-1-章-权衡的艺术" aria-hidden="true">#</a></h2><blockquote><p>“框架设计里到处都体现了权衡的艺术。”</p></blockquote><p>在深入讨论 Vue.js 3 各个模块的实现思路和细节之前，我认为有必 要先来讨论视图层框架设计方面的内容。为什么呢？这是因为当我们 设计一个框架的时候，框架本身的各个模块之间并不是相互独立的， 而是相互关联、相互制约的。因此作为框架设计者，一定要对框架的 定位和方向拥有全局的把控，这样才能做好后续的模块设计和拆分。 同样，作为学习者，我们在学习框架的时候，也应该从全局的角度对 框架的设计拥有清晰的认知，否则很容易被细节困住，看不清全貌。</p><p>另外，从范式的角度来看，我们的框架应该设计成<strong>命令式</strong>的还是 <strong>声明式</strong>的呢？这两种范式有何优缺点？我们能否汲取两者的优点？除 此之外，我们的框架要设计成纯运行时的还是纯编译时的，甚至是<strong>运行时+编译时</strong>的呢？它们之间又有何差异？优缺点分别是什么？这里面 都体现了“权衡”的艺术。</p><h2 id="_1-1-命令式和声明式" tabindex="-1">1.1 命令式和声明式 <a class="header-anchor" href="#_1-1-命令式和声明式" aria-hidden="true">#</a></h2><blockquote><p>从范式上来看，视图层框架通常分为命令式和声明式，它们各有 优缺点。作为框架设计者，应该对两种范式都有足够的认知，这样才 能做出正确的选择，甚至想办法汲取两者的优点并将其捏合。</p></blockquote><p>接下来，我们先来看看命令式框架和声明式框架的概念。早年间 流行的 jQuery 就是典型的命令式框架。命令式框架的一大特点就是关 注过程。例如，我们把下面这段话翻译成对应的代码：</p><div class="language-wiki"><button title="Copy Code" class="copy"></button><span class="lang">wiki</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">01 - 获取 id 为 app 的 div 标签</span></span>
<span class="line"><span style="color:#A6ACCD;">02 - 它的文本内容为 hello world</span></span>
<span class="line"><span style="color:#A6ACCD;">03 - 为其绑定点击事件</span></span>
<span class="line"><span style="color:#A6ACCD;">04 - 当点击时弹出提示：ok</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">对应的代码为：</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">01 $(&#39;#app&#39;) // 获取 div</span></span>
<span class="line"><span style="color:#A6ACCD;">02 .text(&#39;hello world&#39;) // 设置文本内容</span></span>
<span class="line"><span style="color:#A6ACCD;">03 .on(&#39;click&#39;, () =&gt; { alert(&#39;ok&#39;) }) // 绑定点击事件</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>以上就是 jQuery 的代码示例，考虑到有些读者可能没有用过 jQuery，因此我们再用原生 JavaScript 来实现同样的功能：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> div </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// 获取 div</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> div</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerText </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 设置文本内容</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> div</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">click</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">alert</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ok</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// 绑定点击事</span></span>
<span class="line"><span style="color:#A6ACCD;">件</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，自然语言描述能够与代码产生一一对应的关系，代码 本身描述的是“做事的过程”，这符合我们的逻辑直觉。</p><p>那么，什么是声明式框架呢？与命令式框架更加关注过程不同， 声明式框架更加关注结果。结合 Vue.js，我们来看看如何实现上面自 然语言描述的功能：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">01 </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">alert</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ok</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">hello world</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>这段类 HTML 的模板就是 Vue.js 实现如上功能的方式。可以看 到，我们提供的是一个“结果”，至于如何实现这个“结果”，我们并不关 心，这就像我们在告诉 Vue.js：“嘿，Vue.js，看到没，我要的就是一个 div，文本内容是 hello world，它有个事件绑定，你帮我搞定 吧。”至于实现该“结果”的过程，则是由 Vue.js 帮我们完成的。换句话 说，Vue.js 帮我们封装了过程。因此，我们能够猜到 Vue.js 的内部实 现一定是命令式的，而暴露给用户的却更加声明式。</p><h2 id="_1-2-性能与可维护性的权衡" tabindex="-1">1.2 性能与可维护性的权衡 <a class="header-anchor" href="#_1-2-性能与可维护性的权衡" aria-hidden="true">#</a></h2><blockquote><p>命令式和声明式各有优缺点，在框架设计方面，则体现在性能与可维护性之间的权衡。这里我们先抛出一个结论：<strong>声明式代码的性能不优于命令式代码的性能</strong>。</p></blockquote><p>还是拿上面的例子来说，假设现在我们要将 div 标签的文本内容 修改为 hello vue3，那么如何用命令式代码实现呢？很简单，因为 我们明确知道要修改的是什么，所以直接调用相关命令操作即可：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> div</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">textContent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello vue3</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 直接修改</span></span>
<span class="line"></span></code></pre></div><p>现在思考一下，还有没有其他办法比上面这句代码的性能更好？ 答案是“没有”。可以看到，理论上命令式代码可以做到极致的性能优 化，因为我们明确知道哪些发生了变更，只做必要的修改就行了。但 是声明式代码不一定能做到这一点，因为它描述的是结果：</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">01 </span><span style="color:#676E95;font-style:italic;">&lt;!-- 之前： --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">02 </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">alert</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ok</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">hello world</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">03 </span><span style="color:#676E95;font-style:italic;">&lt;!-- 之后： --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">04 </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">alert</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">ok</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">hello vue3</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>对于框架来说，为了实现最优的更新性能，它需要找到前后的差 异并只更新变化的地方，但是最终完成这次更新的代码仍然是：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> div</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">textContent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello vue3</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 直接修改</span></span>
<span class="line"></span></code></pre></div><blockquote><p>如果我们把直接修改的性能消耗定义为 A，把找出差异的性能消 耗定义为 B，那么有：</p><p>命令式代码的更新性能消耗 = A</p><p>声明式代码的更新性能消耗 = B + A</p><p>可以看到，声明式代码会比命令式代码多出找出差异的性能消 耗，因此最理想的情况是，当找出差异的性能消耗为 0 时，声明式代 码与命令式代码的性能相同，但是无法做到超越，毕竟框架本身就是 封装了命令式代码才实现了面向用户的声明式。这符合前文中给出 的性能结论：<strong>声明式代码的性能不优于命令式代码的性能</strong></p></blockquote><p>既然在性能层面命令式代码是更好的选择，那么为什么 Vue.js 要 选择声明式的设计方案呢？原因就在于声明式代码的可维护性更强。 从上面例子的代码中我们也可以感受到，在采用命令式代码开发的时候，我们需要维护实现目标的整个过程，包括要手动完成 DOM 元素 的创建、更新、删除等工作。而声明式代码展示的就是我们要的结 果，看上去更加直观，至于做事儿的过程，并不需要我们关心，Vue.js都为我们封装好了。</p><p>这就体现了我们在框架设计上要做出的关于可维护性与性能之间 的权衡。在采用声明式提升可维护性的同时，性能就会有一定的损 失，而框架设计者要做的就是：<strong>在保持可维护性的同时让性能损失最小化</strong></p><h2 id="_1-3-虚拟-dom-的性能到底如何" tabindex="-1">1.3 虚拟 DOM 的性能到底如何 <a class="header-anchor" href="#_1-3-虚拟-dom-的性能到底如何" aria-hidden="true">#</a></h2><p>考虑到有些读者可能不知道什么是虚拟 DOM，这里我们不会对其 做深入讨论，但这既不影响你理解本节内容，也不影响你阅读后续章 节。如果实在看不明白，也没关系，至少有个印象，等后面我们深入 讲解虚拟 DOM 后再回来看这里的内容，相信你会有不同的感受。</p><p>前文说到，声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗，因此，如果我们能够最小化找出差异的性能 消耗，就可以让声明式代码的性能无限接近命令式代码的性能。而所 谓的虚拟 DOM，就是为了最小化找出差异这一步的性能消耗而出现的。 至此，相信你也应该清楚一件事了，那就是采用虚拟 DOM 的更新 技术的性能理论上不可能比原生 JavaScript 操作 DOM 更高。</p><p>这里我们 强调了理论上三个字，因为这很关键，为什么呢？因为在大部分情况 下，我们很难写出绝对优化的命令式代码，尤其是当应用程序的规模 很大的时候，即使你写出了极致优化的代码，也一定耗费了巨大的精力，这时的投入产出比其实并不高。</p><p>那么，有没有什么办法能够让我们不用付出太多的努力（写声明 式代码），还能够保证应用程序的性能下限，让应用程序的性能不至 于太差，甚至想办法逼近命令式代码的性能呢？这其实就是虚拟 DOM 要解决的问题。</p><p>不过前文中所说的原生 JavaScript 实际上指的是像 document.createElement 之类的 DOM 操作方法，并不包含 innerHTML，因为它比较特殊，需要单独讨论。在早年使用 jQuery 或 者直接使用 JavaScript 编写页面的时候，使用 innerHTML 来操作页面 非常常见。其实我们可以思考一下：使用 innerHTML 操作页面和虚 拟 DOM 相比性能如何？innerHTML 和 document.createElement 等 DOM 操作方法有何差异？</p><p>先来看第一个问题，为了比较 innerHTML 和虚拟 DOM 的性能， 我们需要了解它们创建、更新页面的过程。对于 innerHTML 来说， 为了创建页面，我们需要构造一段 HTML 字符串：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> html </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#C3E88D;">02 &lt;div&gt;&lt;span&gt;...&lt;/span&gt;&lt;/div&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">03 </span><span style="color:#89DDFF;">\`</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 接着将该字符串赋值给 DOM 元素的 innerHTML 属性：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> div</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> html</span></span>
<span class="line"></span></code></pre></div><p>然而这句话远没有看上去那么简单。为了渲染出页面，首先要把 字符串解析成 DOM 树，这是一个 DOM 层面的计算。我们知道，涉及 DOM 的运算要远比 JavaScript 层面的计算性能差，这有一个跑分结果 可供参考，如图 1-1 所示。</p><p><img src="`+p+'" alt="image-20230413101814544"></p><p>在图 1-1 中，上边是纯 JavaScript 层面的计算，循环 10 000 次，每次创建一个 JavaScript 对象并将其添加到数组中；下边是 DOM 操作， 每次创建一个 DOM 元素并将其添加到页面中。跑分结果显示，纯 JavaScript 层面的操作要比 DOM 操作快得多，它们不在一个数量级 上。基于这个背景，我们可以用一个公式来表达通过 innerHTML 创 建页面的性能：HTML 字符串拼接的计算量 + innerHTML 的 DOM 计算量。</p><p>接下来，我们讨论虚拟 DOM 在创建页面时的性能。虚拟 DOM 创 建页面的过程分为两步：第一步是创建 JavaScript 对象，这个对象可以 理解为真实 DOM 的描述；第二步是递归地遍历虚拟 DOM 树并创建真 实 DOM。我们同样可以用一个公式来表达：创建 JavaScript 对象的 计算量 + 创建真实 DOM 的计算量。</p><p><img src="'+o+'" alt="image-20230413103620394"></p><p>可以看到，无论是纯 JavaScript 层面的计算，还是 DOM 层面的计 算，其实两者差距不大。这里我们从宏观的角度只看数量级上的差 异。如果在同一个数量级，则认为没有差异。在创建页面的时候，都 需要新建所有 DOM 元素。</p><p>刚刚我们讨论了创建页面时的性能情况，大家可能会觉得虚拟 DOM 相比 innerHTML 没有优势可言，甚至细究的话性能可能会更差。</p><p>别着急，接下来我们看看它们在更新页面时的性能。 使用 innerHTML 更新页面的过程是重新构建 HTML 字符串， 再重新设置 DOM 元素的 innerHTML 属性，这其实是在说，哪怕我们只更改了一个文字，也要重新设置 innerHTML 属性。而重新设置 innerHTML 属性就等价于销毁所有旧的 DOM 元素，再全量创建新 的 DOM 元素。再来看虚拟 DOM 是如何更新页面的。它需要重新创 建 JavaScript 对象（虚拟 DOM 树），然后比较新旧虚拟 DOM，找到 变化的元素并更新它。图 1-3 可作为对照。</p><p><img src="'+e+'" alt="image-20230413103911816"></p><p>可以发现，在更新页面时，虚拟 DOM 在 JavaScript 层面的运算要 比创建页面时多出一个 Diff 的性能消耗，然而它毕竟也是 JavaScript 层 面的运算，所以不会产生数量级的差异。再观察 DOM 层面的运算，可 以发现虚拟 DOM 在更新页面时只会更新必要的元素，但 innerHTML 需要全量更新。这时虚拟 DOM 的优势就体现出来了。</p><p>另外，我们发现，当更新页面时，影响虚拟 DOM 的性能因素与影 响 innerHTML 的性能因素不同。对于虚拟 DOM 来说，无论页面多 大，都只会更新变化的内容，而对于 innerHTML 来说，页面越大， 就意味着更新时的性能消耗越大。如果加上性能因素，那么最终它们 在更新页面时的性能如图 1-4 所示。</p><p><img src="'+t+'" alt="image-20230413104023389"></p><p><img src="'+c+`" alt="image-20230413104236688"></p><p>我们分了几个维度：心智负担、可维护性和性能。</p><p>其中原生 DOM 操作方法的心智负担最大，因为你要手动创建、删除、修改大量的 DOM 元素。但它的性能是最高的，不过为了使其性能最佳，我们同样 要承受巨大的心智负担。另外，以这种方式编写的代码，可维护性也 极差。而对于 innerHTML 来说，由于我们编写页面的过程有一部分 是通过拼接 HTML 字符串来实现的，这有点儿接近声明式的意思，但 是拼接字符串总归也是有一定心智负担的，而且对于事件绑定之类的 事情，我们还是要使用原生 JavaScript 来处理。如果 innerHTML 模板 很大，则其更新页面的性能最差，尤其是在只有少量更新时。最后， 我们来看看虚拟 DOM，它是声明式的，因此心智负担小，可维护性 强，性能虽然比不上极致优化的原生 JavaScript，但是在保证心智负担 和可维护性的前提下相当不错。</p><p>至此，我们有必要思考一下：有没有办法做到，既声明式地描述 UI，又具备原生 JavaScript 的性能呢？看上去有点儿鱼与熊掌兼得的意 思，我们会在下一章中继续讨论。</p><h2 id="_1-4-运行时和编译时" tabindex="-1">1.4 运行时和编译时 <a class="header-anchor" href="#_1-4-运行时和编译时" aria-hidden="true">#</a></h2><blockquote><p>当设计一个框架的时候，我们有三种选择：纯运行时的、运行时 + 编译时的或纯编译时的。这需要你根据目标框架的特征，以及对框架 的期望，做出合适的决策。另外，为了做出合适的决策，你需要清楚 地知道什么是运行时，什么是编译时，它们各自有什么特征，它们对 框架有哪些影响，本节将会逐步讨论这些内容</p></blockquote><p>我们先聊聊纯运行时的框架。假设我们设计了一个框架，它提供 一个 Render 函数，用户可以为该函数提供一个树型结构的数据对象，然后 Render 函数会根据该对象递归地将数据渲染成 DOM 元 素。我们规定树型结构的数据对象如下：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;"> 	</span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;"> 	</span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span></span>
<span class="line"><span style="color:#A6ACCD;"> 		</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">span</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"> 	]</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>每个对象都有两个属性：tag 代表标签名称，children 既可以 是一个数组（代表子节点），也可以直接是一段文本（代表文本子节 点）。接着，我们来实现 Render 函数：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Render</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">root</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">el</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">tag</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">string</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    	 </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">text</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createTextNode</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    	 </span><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">text</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    	 </span><span style="color:#676E95;font-style:italic;">// 数组，递归调用 Render，使用 el 作为 root 参数</span></span>
<span class="line"><span style="color:#F07178;">    	 </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">children</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">child</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Render</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">child</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">el</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">     </span><span style="color:#676E95;font-style:italic;">// 将元素添加到 root</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#A6ACCD;">root</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">el</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>有了这个函数，用户就可以这样来使用它：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">     </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">tag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">span</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">     ]</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;"> </span><span style="color:#676E95;font-style:italic;">// 渲染到 body 下</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Render</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body)</span></span>
<span class="line"></span></code></pre></div><p>现在我们回过头来思考一下用户是如何使用 Render 函数的。可以发现，用户在使用它渲染内容时，直接为 Render 函数提供了一个 树型结构的数据对象。这里面不涉及任何额外的步骤，用户也不需要 学习额外的知识。但是有一天，你的用户抱怨说：“手写树型结构的数 据对象太麻烦了，而且不直观，能不能支持用类似于 HTML 标签的方 式描述树型结构的数据对象呢？”你看了看现在的 Render 函数，然后 回答：“抱歉，暂不支持。”实际上，我们刚刚编写的框架就是一个纯 运行时的框架。</p><p>为了满足用户的需求，你开始思考，能不能引入编译的手段，把 HTML 标签编译成树型结构的数据对象，这样不就可以继续使用 Render 函数了吗？思路如图 1-6 所示。</p><p><img src="`+r+`" alt="image-20230413105303246"></p><p>为此，你编写了一个叫作 Compiler 的程序，它的作用就是把 HTML 字符串编译成树型结构的数据对象，于是交付给用户去用了。 那么用户该怎么用呢？其实这也是我们要思考的问题，最简单的方式 就是让用户分别调用 Compiler 函数和 Render 函数：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> html </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#C3E88D;">02 &lt;div&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">03 &lt;span&gt;hello world&lt;/span&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">04 &lt;/div&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">05 </span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 调用 Compiler 编译得到树型结构的数据对象</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Compiler</span><span style="color:#A6ACCD;">(html)</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 再调用 Render 进行渲染</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Render</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body)</span></span>
<span class="line"></span></code></pre></div><p>上面这段代码能够很好地工作，这时我们的框架就变成了一个运行时 + 编译时的框架。它既支持运行时，用户可以直接提供数据对象 从而无须编译；又支持编译时，用户可以提供 HTML 字符串，我们将 其编译为数据对象后再交给运行时处理。准确地说，上面的代码其实 是运行时编译，意思是代码运行的时候才开始编译，而这会产生一定 的性能开销，因此我们也可以在构建的时候就执行 Compiler 程序将 用户提供的内容编译好，等到运行时就无须编译了，这对性能是非常 友好的。</p><p>不过，聪明的你一定意识到了另外一个问题：既然编译器可以把 HTML 字符串编译成数据对象，那么能不能直接编译成命令式代码 呢？图 1-7 展示了将 HTML 字符串编译为命令式代码的过程。</p><p><img src="`+y+`" alt="image-20230413105522514"></p><p>这样我们只需要一个 Compiler 函数就可以了，连 Render 都不 需要了。其实这就变成了一个纯编译时的框架，因为我们不支持任何 运行时内容，用户的代码通过编译器编译后才能运行。</p><p>我们用简单的例子讲解了框架设计层面的运行时、编译时以及运 行时 + 编译时。我们发现，一个框架既可以是纯运行时的，也可以是 纯编译时的，还可以是既支持运行时又支持编译时的。那么，它们都 有哪些优缺点呢？是不是既支持运行时又支持编译时的框架最好呢？ 为了搞清楚这个问题，我们逐个分析。</p><p>首先是纯运行时的框架。由于它没有编译的过程，因此我们没办 法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样 了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变， 哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信 息，然后将其传递给 Render 函数，Render 函数得到这些信息之 后，就可以做进一步的优化了。然而，假如我们设计的框架是纯编译 时的，那么它也可以分析用户提供的内容。由于不需要任何运行时， 而是直接编译成可执行的 JavaScript 代码，因此性能可能会更好，但是 这种做法有损灵活性，即用户提供的内容必须编译后才能用。实际 上，在这三个方向上业内都有探索，其中 Svelte 就是纯编译时的框 架，但是它的真实性能可能达不到理论高度。Vue.js 3 仍然保持了运行 时 + 编译时的架构，在保持灵活性的基础上能够尽可能地去优化。等 到后面讲解 Vue.js3 的编译优化相关内容时，你会看到 Vue.js 3 在保留 运行时的情况下，其性能甚至不输纯编译时的框架。</p><h2 id="_1-5-总结" tabindex="-1">1.5 总结 <a class="header-anchor" href="#_1-5-总结" aria-hidden="true">#</a></h2><ol><li><p>在本章中，我们先讨论了命令式和声明式这两种范式的差异，其 中命令式更加关注过程，而声明式更加关注结果。命令式在理论上可 以做到极致优化，但是用户要承受巨大的心智负担；而声明式能够有 效减轻用户的心智负担，但是性能上有一定的牺牲，框架设计者要想 办法尽量使性能损耗最小化。</p></li><li><p>接着，我们讨论了虚拟 DOM 的性能，并给出了一个公式：声明 式的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。 虚拟 DOM 的意义就在于使找出差异的性能消耗最小化。我们发现，用 原生 JavaScript 操作 DOM 的方法（如 document.createElement）、虚拟 DOM 和 innerHTML 三者操 作页面的性能，不可以简单地下定论，这与页面大小、变更部分的大小都有关系，除此之外，与创建页面还是更新页面也有关系，选择哪 种更新策略，需要我们结合心智负担、可维护性等因素综合考虑。一 番权衡之后，我们发现虚拟 DOM 是个还不错的选择。</p></li><li><p>最后，我们介绍了运行时和编译时的相关知识，了解纯运行时、 纯编译时以及两者都支持的框架各有什么特点，并总结出 Vue.js 3 是一 个编译时 + 运行时的框架，它在保持灵活性的基础上，还能够通过编 译手段分析用户提供的内容，从而进一步提升更新性能。</p></li></ol><h2 id="第-2-章-框架设计的核心要素" tabindex="-1">第 2 章 框架设计的核心要素 <a class="header-anchor" href="#第-2-章-框架设计的核心要素" aria-hidden="true">#</a></h2><p>框架设计要比想象得复杂，并不是说只把功能开发完成，能用就 算大功告成了，这里面还有很多学问。比如，我们的框架应该给用户 提供哪些构建产物？产物的模块格式如何？当用户没有以预期的方式 使用框架时，是否应该打印合适的警告信息从而提供更好的开发体 验，让用户快速定位问题？开发版本的构建和生产版本的构建有何区 别？热更新（hot module replacement，HMR）需要框架层面的支持， 我们是否也应该考虑？另外，当你的框架提供了多个功能，而用户只 需要其中几个功能时，用户能否选择关闭其他功能从而减少最终资源 的打包体积？上述问题是我们在设计框架的过程中应该考虑的。</p><p>学习本章时，要求大家对常用的模块打包工具有一定的使用经 验，尤其是 rollup.js 和 webpack。如果你只用过或了解过其中一个，也 没关系，因为它们的很多概念其实是类似的。如果你没有使用过任何 模块打包工具，那么需要自行了解一下，有了初步认识之后再来阅读 本章会更好一些。</p><h2 id="_2-1-提升用户的开发体验" tabindex="-1">2.1 提升用户的开发体验 <a class="header-anchor" href="#_2-1-提升用户的开发体验" aria-hidden="true">#</a></h2><p>衡量一个框架是否足够优秀的指标之一就是看它的开发体验如 何，这里我们拿 Vue.js 3 举个例子：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createApp</span><span style="color:#A6ACCD;">(App)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">mount</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">#not-exist</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>当我们创建一个 Vue.js 应用并试图将其挂载到一个不存在的 DOM 节点时，就会收到一条警告信息，如图 2-1 所示。</p><p><img src="`+C+`" alt="image-20230413111937988"></p><p>这条信息告诉我们挂载失败了，并说明了失败的原因：Vue.js 根据 我们提供的选择器无法找到相应的 DOM 元素（返回 null）。这条信 息让我们能够清晰且快速地定位问题。试想一下，如果 Vue.js 内部不 做任何处理，那么我们很可能得到的是 JavaScript 层面的错误信息，例 如 Uncaught TypeError: Cannot read property &#39;xxx&#39; of null，而根据此信息我们很难知道问题出在哪里。</p><p>所以在框架设计和开发过程中，提供友好的警告信息至关重要。 如果这一点做得不好，那么很可能会经常收到用户的抱怨。始终提供 友好的警告信息不仅能够帮助用户快速定位问题，节省用户的时间， 还能够让框架收获良好的口碑，让用户认可框架的专业性。</p><p>在 Vue.js 的源码中，我们经常能够看到 warn 函数的调用，例如 图 2-1 中的信息就是由下面这个 warn 函数调用打印的：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">warn</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Failed to mount app: mount target selector &quot;</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">&quot;</span></span>
<span class="line"><span style="color:#C3E88D;">returned null.</span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#A6ACCD;"> )</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>对于 warn 函数来说，由于它需要尽可能提供有用的信息，因此 它需要收集当前发生错误的组件栈信息。如果你去看源码，就会发现 有些复杂，但其实最终就是调用了 console.warn 函数。</p><p>除了提供必要的警告信息外，还有很多其他方面可以作为切入 口，进一步提升用户的开发体验。例如，在 Vue.js 3 中，当我们在控制 台打印一个 ref 数据时：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(count)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p><img src="`+D+'" alt="image-20230413112223908"></p><p>可以发现，打印的数据非常不直观。当然，我们可以选择直接打 印 count.value 的值，这样就只会输出 0，非常直观。那么有没有 办法在打印 count 的时候让输出的信息更友好呢？当然可以，浏览器 允许我们编写自定义的 formatter，从而自定义输出形式。在 Vue.js 3 的源码中，你可以搜索到名为 initCustomFormatter 的函数，该 函数就是用来在开发环境下初始化自定义 formatter 的。以 Chrome 为例，我们可以打开 DevTools 的设置，然后勾选“Console”→“Enable custom formatters”选项，如图 2-3 所示。</p><img src="'+F+`" alt="image-20230413112255465" style="zoom:50%;"><h2 id="_2-2-控制框架代码的体积" tabindex="-1">2.2 控制框架代码的体积 <a class="header-anchor" href="#_2-2-控制框架代码的体积" aria-hidden="true">#</a></h2><blockquote><p>框架的大小也是衡量框架的标准之一。在实现同样功能的情况 下，当然是用的代码越少越好，这样体积就会越小，最后浏览器加载 资源的时间也就越少。这时我们不禁会想，提供越完善的警告信息就 意味着我们要编写更多的代码，这不是与控制代码体积相悖吗？没 错，所以我们要想办法解决这个问题。</p></blockquote><p>如果我们去看 Vue.js 3 的源码，就会发现每一个 warn 函数的调用 都会配合 <strong>DEV</strong> 常量的检查，例如：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (__DEV__ </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">res) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	 </span><span style="color:#82AAFF;">warn</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;"> 		</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Failed to mount app: mount target selector &quot;</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">&quot;</span></span>
<span class="line"><span style="color:#C3E88D;">    	returned null.</span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#F07178;">     )</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，打印警告信息的前提是：<strong>DEV</strong> 这个常量一定要为 true，这里的 <strong>DEV</strong> 常量就是达到目的的关键。</p><p>Vue.js 使用 rollup.js 对项目进行构建，这里的 <strong>DEV</strong> 常量实际 上是通过 rollup.js 的插件配置来预定义的，其功能类似于 webpack 中的 DefinePlugin 插件。</p><p>Vue.js 在输出资源的时候会输出两个版本，其中一个用于开发环 境，如 vue.global.js，另一个用于生产环境，如 vue.global.prod.js，通过 文件名我们也能够区分。</p><p>当 Vue.js 构建用于开发环境的资源时，会把 <strong>DEV</strong> 常量设置为 true，这时上面那段输出警告信息的代码就等价于：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (</span><span style="color:#FF9CAC;">true</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">res) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	 </span><span style="color:#82AAFF;">warn</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;"> 		</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Failed to mount app: mount target selector &quot;</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">&quot;</span></span>
<span class="line"><span style="color:#C3E88D;">    	returned null.</span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#F07178;">     )</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>当 Vue.js 用于构建生产环境的资源时，会把 <strong>DEV</strong> 常量设置为 false，这时上面那段输出警告信息的代码就等价于：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (</span><span style="color:#FF9CAC;">false</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">res) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	 </span><span style="color:#82AAFF;">warn</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;"> 		</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Failed to mount app: mount target selector &quot;</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">&quot;</span></span>
<span class="line"><span style="color:#C3E88D;">    	returned null.</span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#F07178;">     )</span></span>
<span class="line"><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>可以看到，<strong>DEV</strong> 常量替换为字面量 false，这时我们发现这 段分支代码永远都不会执行，因为判断条件始终为假，这段永远不会 执行的代码称为 dead code，它不会出现在最终产物中，在构建资源的 时候就会被移除，因此在 vue.global.prod.js 中是不会存在这段代码的。</p><p>这样我们就做到了在开发环境中为用户提供友好的警告信息的 同时，不会增加生产环境代码的体积。</p><h2 id="_2-3-框架要做到良好的-tree-shaking" tabindex="-1">2.3 框架要做到良好的 Tree-Shaking <a class="header-anchor" href="#_2-3-框架要做到良好的-tree-shaking" aria-hidden="true">#</a></h2><p>上文提到通过构建工具设置预定义的常量 <strong>DEV</strong>，就能够在生 产环境中使得框架不包含用于打印警告信息的代码，从而使得框架自 身的代码量不随警告信息的增加而增加。但是从用户的角度来看，这 么做仍然不够，还是拿 Vue.js 来举个例子。我们知道 Vue.js 内建了很 多组件，例如<code>Transition</code>组件，如果我们的项目中根本就没有用 到该组件，那么它的代码需要包含在项目最终的构建资源中吗？答案 是“当然不需要”，那么如何做到这一点呢？这就不得不提到本节的主角 Tree-Shaking。</p><p>什么是 Tree-Shaking 呢？在前端领域，这个概念因 rollup.js 而普 及。简单地说，Tree-Shaking 指的就是消除那些永远不会被执行的代 码，也就是排除 dead code，现在无论是 rollup.js 还是 webpack，都支持 Tree-Shaking。</p><p>想要实现 Tree-Shaking，必须满足一个条件，即模块必须是 ESM（ES Module），因为 Tree-Shaking 依赖 ESM 的静态结构。我们 以 rollup.js 为例看看 Tree-Shaking 如何工作，其目录结构如下：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> ├── demo</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> │ └── package</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> │ └── input</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> │ └── utils</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 首先安装 rollup.js：</span></span>
<span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> yarn add rollup </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">D</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> # 或者 npm install rollup </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">D</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//下面是 input.js 和 utils.js 文件的内容：</span></span>
<span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// input.js</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">foo</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./utils.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// utils.js</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>代码很简单，我们在 utils.js 文件中定义并导出了两个函数，分别 是 foo 函数和 bar 函数，然后在 input.js 中导入了 foo 函数并执行。 注意，我们并没有导入 bar 函数。 接着，我们执行如下命令进行构建：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">npx rollup input</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">f esm </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">o bundle</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"></span></code></pre></div><p>这句命令的意思是，以 input.js 文件为入口，输出 ESM，输出的文 件叫作 bundle.js。命令执行成功后，我们打开 bundle.js 来查看一下它 的内容：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// bundle.js</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> 	</span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>可以看到，其中并不包含 bar 函数，这说明 Tree-Shaking 起了作 用。由于我们并没有使用 bar 函数，因此它作为 dead code 被删除了。 但是仔细观察会发现，foo 函数的执行也没有什么意义，仅仅是读取 了对象的值，所以它的执行似乎没什么必要。既然把这段代码删了也 不会对我们的应用程序产生影响，那么为什么 rollup.js 不把这段代码也 作为 dead code 移除呢？</p><p>这就涉及 Tree-Shaking 中的第二个关键点——副作用。如果一个 函数调用会产生副作用，那么就不能将其移除。什么是副作用？简单 地说，副作用就是，当调用函数的时候会对外部产生影响，例如修改 了全局变量。这时你可能会说，上面的代码明显是读取对象的值，怎 么会产生副作用呢？其实是有可能的，试想一下，如果 obj 对象是一 个通过 Proxy 创建的代理对象，那么当我们读取对象属性时，就会触 发代理对象的 get 夹子（trap），在 get 夹子中是可能产生副作用 的，例如我们在 get 夹子中修改了某个全局变量。而到底会不会产生 副作用，只有代码真正运行的时候才能知道，JavaScript 本身是动态语 言，因此想要静态地分析哪些代码是 dead code 很有难度，上面只是举 了一个简单的例子。</p><p>因为静态地分析 JavaScript 代码很困难，所以像 rollup.js 这类工具 都会提供一个机制，让我们能明确地告诉 rollup.js：“放心吧，这段代 码不会产生副作用，你可以移除它。”具体怎么做呢？如以下代码所 示，我们修改 input.js 文件：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./utils</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*#__PURE__*/</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span></code></pre></div><p>注意注释代码 /*#<strong>PURE</strong>*/，其作用就是告诉 rollup.js，对于 foo 函数的调用不会产生副作用，你可以放心地对其进行 TreeShaking，此时再次执行构建命令并查看 bundle.js 文件，就会发现它的 内容是空的，这说明 Tree-Shaking 生效了。</p><p>基于这个案例，我们应该明白，在编写框架的时候需要合理使用 /*#<strong>PURE</strong>*/ 注释。如果你去搜索 Vue.js 3 的源码，会发现它大量 使用了该注释，例如下面这句</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> isHTMLTag </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">/*#__PURE__*/</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">makeMap</span><span style="color:#A6ACCD;">(HTML_TAGS)</span></span>
<span class="line"></span></code></pre></div><p>这会不会对编写代码造成很大的心智负担呢？其实不会，因为通 常产生副作用的代码都是模块内函数的顶级调用。什么是顶级调用 呢？如以下代码所示：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">() </span><span style="color:#676E95;font-style:italic;">// 顶级调用</span></span>
<span class="line"><span style="color:#F78C6C;">02</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#F07178;">() </span><span style="color:#676E95;font-style:italic;">// 函数内调用</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，对于顶级调用来说，是可能产生副作用的；但对于函 数内调用来说，只要函数 bar 没有被调用，那么 foo 函数的调用自然 不会产生副作用。因此，在 Vue.js 3 的源码中，基本都是在一些顶级调 用的函数上使用 /<em>#<strong>PURE</strong></em>/ 注释。当然，该注释不仅仅作用于 函数，它可以应用于任何语句上。该注释也不是只有 rollup.js 才能识 别，webpack 以及压缩工具（如 terser）都能识别它。</p><h2 id="_2-4-框架应该输出怎样的构建产物" tabindex="-1">2.4 框架应该输出怎样的构建产物 <a class="header-anchor" href="#_2-4-框架应该输出怎样的构建产物" aria-hidden="true">#</a></h2><p>上文提到 Vue.js 会为开发环境和生产环境输出不同的包，例如 vue.global.js 用于开发环境，它包含必要的警告信息，而 vue.global.prod.js 用于生产环境，不包含警告信息。实际上，Vue.js 的 构建产物除了有环境上的区分之外，还会根据使用场景的不同而输出 其他形式的产物。本节中，我们将讨论这些产物的用途以及在构建阶 段如何输出这些产物。</p><p>不同类型的产物一定有对应的需求背景，因此我们从需求讲起。 首先我们希望用户可以直接在 HTML 页面中使用</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">01 </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">body</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">02 </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/path/to/vue.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">03 </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> createApp </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Vue</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">07 </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">body</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>为了实现这个需求，我们需要输出一种叫作 IIFE 格式的资源。 IIFE 的全称是 Immediately Invoked Function Expression，即“立即调用的 函数表达式”，易于用 JavaScript 来表达：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">())</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>如以上代码所示，这是一个立即执行的函数表达式。实际上， vue.global.js 文件就是 IIFE 形式的资源，它的代码结构如下所示：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> Vue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">exports</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">exports.</span><span style="color:#A6ACCD;">createApp</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">createApp</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">exports</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;">))</span></span>
<span class="line"></span></code></pre></div><p>这样当我们使用 script 标签直接引入 vue.global.js 文件后，全局变量 Vue 就是可用的了。</p><p>在 rollup.js 中，我们可以通过配置 format: &#39;iife&#39; 来输出这种 形式的资源：</p><p>不过随着技术的发展和浏览器的支持，现在主流浏览器对原生ESM 的支持都不错，所以用户除了能够使用 script 标签引用 IIFE格式的资源外，还可以直接引入 ESM 格式的资源，例如 Vue.js 3 还会输出 vue.esm-browser.js 文件，用户可以直接用 script type=&quot;module&quot; 标签引入：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">script type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/path/to/vue.esm-browser.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#A6ACCD;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>为了输出 ESM 格式的资源，rollup.js 的输出格式需要配置为： format: &#39;esm&#39;。</p><p>你可能已经注意到了，为什么 vue.esm-browser.js 文件中会有 - browser 字样？其实对于 ESM 格式的资源来说，Vue.js 还会输出一个 vue.esm-bundler.js 文件，其中 -browser 变成了 -bundler。为什么 这么做呢？我们知道，无论是 rollup.js 还是 webpack，在寻找资源时， 如果 package.json 中存在 module 字段，那么会优先使用 module 字 段指向的资源来代替 main 字段指向的资源。我们可以打开 Vue.js 源 码中的 packages/vue/package.json 文件看一下：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">main</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">index.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">dist/vue.runtime.esm-bundler.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>其中 module 字段指向的是 vue.runtime.esm-bundler.js 文件，意思是说，如果项目是使用 webpack 构建的，那么你使用的 Vue.js 资源就是vue.runtime.esm-bundler.js 也就是说，带有 -bundler 字样的 ESM 资源是给 rollup.js 或 webpack 等打包工具使用的，而带有 -browser 字样的 ESM 资源是直接给 script type=&quot;module&quot; 使用的。它们之间有何区别？这就不得不提到上文中的 <strong>DEV</strong> 常量。当构建用于script 标签的 ESM 资源时，如果是用于开发环境，那么__DEV__ 会设置为 true；如果是用于生产环境，那么 <strong>DEV</strong> 常量会设置为 false，从而被 Tree-Shaking 移除。但是当我们构建提供给打包工具的 ESM 格式的资源时，不能直接把 <strong>DEV</strong> 设置为 true或 false，而要使用 (p<wbr>rocess.env.NODE_ENV !==&#39;production&#39;) 替换 <strong>DEV</strong> 常量。例如下面的源码：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (__DEV__) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;">  </span><span style="color:#82AAFF;">warn</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">useCssModule() is not supported in the global build.</span><span style="color:#89DDFF;">\`</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>在带有 -bundler 字样的资源中会变成：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> ((process</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">env</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">NODE_ENV </span><span style="color:#89DDFF;">!==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">production</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">warn</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">useCssModule() is not supported in the global build.</span><span style="color:#89DDFF;">\`</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>这样做的好处是，用户可以通过 webpack 配置自行决定构建资源 的目标环境，但是最终效果其实一样，这段代码也只会出现在开发环 境中。</p><p>用户除了可以直接使用 script 标签引入资源外，我们还希望用户可以在 Node.js 中通过 require 语句引用资源，例如：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Vue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>为什么会有这种需求呢？答案是“服务端渲染”。当进行服务端渲 染时，Vue.js 的代码是在 Node.js 环境中运行的，而非浏览器环境。在 Node.js 环境中，资源的模块格式应该是 CommonJS，简称 cjs。为了能 够输出 cjs 模块的资源，我们可以通过修改 rollup.config.js 的配置 format: &#39;cjs&#39; 来实现：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// rollup.config.js</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> config </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;">  	input</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">input.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;">  	output</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;">  	file</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">output.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> 		format</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">cjs</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 指定模块形式</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">09</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> config</span></span>
<span class="line"></span></code></pre></div><h2 id="_2-5-特性开关" tabindex="-1">2.5 特性开关 <a class="header-anchor" href="#_2-5-特性开关" aria-hidden="true">#</a></h2><h3 id="_2-5-特性开关-1" tabindex="-1">2.5 特性开关 <a class="header-anchor" href="#_2-5-特性开关-1" aria-hidden="true">#</a></h3><blockquote><p>在设计框架时，框架会给用户提供诸多特性（或功能），例如我 们提供 A、B、C 三个特性给用户，同时还提供了 a、b、c 三个对应的 特性开关，用户可以通过设置 a、b、c 为 true 或 false 来代表开启 或关闭对应的特性，这将会带来很多益处。</p></blockquote><p>对于用户关闭的特性，我们可以利用 Tree-Shaking 机制让其不包 含在最终的资源中。 该机制为框架设计带来了灵活性，可以通过特性开关任意为框架 添加新的特性，而不用担心资源体积变大。同时，当框架升级 时，我们也可以通过特性开关来支持遗留 API，这样新用户可以选 择不使用遗留 API，从而使最终打包的资源体积最小化。</p><p>那怎么实现特性开关呢？其实很简单，原理和上文提到的 <strong>DEV</strong> 常量一样，本质上是利用 rollup.js 的预定义常量插件来实 现。拿 Vue.js 3 源码中的一段 rollup.js 配置来说：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">__FEATURE_OPTIONS_API__</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isBundlerESMBuild</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">?</span></span>
<span class="line"><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">_<wbr>_VUE_OPTIONS_API__</span><span style="color:#89DDFF;">\`</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>其中 <strong>FEATURE_OPTIONS_API</strong> 类似于 <strong>DEV</strong>。在 Vue.js 3 的 源码中搜索，可以找到很多类似于如下代码的判断分支：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// support for 2.x options</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (__FEATURE_OPTIONS_API__) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> 	</span><span style="color:#A6ACCD;">currentInstance</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">instance</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> 	</span><span style="color:#82AAFF;">pauseTracking</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> 	</span><span style="color:#82AAFF;">applyOptions</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">instance</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Component</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> 	</span><span style="color:#82AAFF;">resetTracking</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> 	</span><span style="color:#A6ACCD;">currentInstance</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>当 Vue.js 构建资源时，如果构建的资源是供打包工具使用的（即 带有 -bundler 字样的资源），那么上面的代码在资源中会变成：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// support for 2.x options</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (_<wbr>_VUE_OPTIONS_API__) </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 注意这里</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> 	</span><span style="color:#A6ACCD;">currentInstance</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">instance</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> 	</span><span style="color:#82AAFF;">pauseTracking</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> 	</span><span style="color:#82AAFF;">applyOptions</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">instance</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Component</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> 	</span><span style="color:#82AAFF;">resetTracking</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> 	</span><span style="color:#A6ACCD;">currentInstance</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>其中 <strong>VUE_OPTIONS_API</strong> 是一个特性开关，用户可以通过设置 <strong>VUE_OPTIONS_API</strong> 预定义常量的值来控制是否要包含这段代 码。通常用户可以使用 webpack.DefinePlugin 插件来实现：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// webpack.DefinePlugin 插件配置</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> webpack</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">DefinePlugin</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> 	_<wbr>_VUE_OPTIONS_API__</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#A6ACCD;">(</span><span style="color:#FF9CAC;">true</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// 开启特性</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>最后详细解释 <strong>VUE_OPTIONS_API</strong> 开关有什么用。在 Vue.js 2 中，我们编写的组件叫作组件选项 API：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> data</span><span style="color:#A6ACCD;">() {</span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// data 选项</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">computed</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// computed 选项</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 其他选项</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>但是在 Vue.js 3 中，推荐使用 Composition API 来编写代码，例 如：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> 	setup</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> 		const count = ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> 		const doubleCount = computed</span><span style="color:#A6ACCD;">(() =&gt; count.value * </span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// 相当于Vue.js 2 中的 computed 选项</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;">	 </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span></code></pre></div><p>但是为了兼容 Vue.js 2，在 Vue.js 3 中仍然可以使用选项 API 的方 式编写代码。但是如果明确知道自己不会使用选项 API，用户就可以使 用 <strong>VUE_OPTIONS_API</strong> 开关来关闭该特性，这样在打包的时候 Vue.js 的这部分代码就不会包含在最终的资源中，从而减小资源体积。</p><h2 id="_2-6-错误处理" tabindex="-1">2.6 错误处理 <a class="header-anchor" href="#_2-6-错误处理" aria-hidden="true">#</a></h2><p>错误处理是框架开发过程中非常重要的环节。框架错误处理机制 的好坏直接决定了用户应用程序的健壮性，还决定了用户开发时处理 错误的心智负担。</p><p>为了让大家更加直观地感受错误处理的重要性，我们从一个小例 子说起。假设我们开发了一个工具模块，代码如下：</p><div class="language-javaScript"><button title="Copy Code" class="copy"></button><span class="lang">javaScript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// utils.js</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> 	foo</span><span style="color:#A6ACCD;">(fn) {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> 		fn &amp;&amp; fn</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> 	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>该模块导出一个对象，其中 foo 属性是一个函数，接收一个回调 函数作为参数，调用 foo 函数时会执行该回调函数，在用户侧使用 时：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> utils </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utils.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> utils</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>大家思考一下，如果用户提供的回调函数在执行的时候出错了， 怎么办？此时有两个办法，第一个办法是让用户自行处理，这需要用 户自己执行 try...catch：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> utils </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utils.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> utils</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;">	 </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;">	 </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;">	 </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">e</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;">	 </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;">	 </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>但是这会增加用户的负担。试想一下，如果 utils.js 不是仅仅提供 了一个 foo 函数，而是提供了几十上百个类似的函数，那么用户在使 用的时候就需要逐一添加错误处理程序。</p><p>第二个办法是我们代替用户统一处理错误，如以下代码所示：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// utils.js</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> foo</span><span style="color:#A6ACCD;">(fn) {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> try {</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> fn &amp;&amp; fn</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">catch</span><span style="color:#A6ACCD;">(e) </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/* ... */</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> }</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#A6ACCD;">(fn) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/* ... */</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>在每个函数内都增加 try...catch 代码块，实际上，我们可以 进一步将错误处理程序封装为一个函数，假设叫它 callWithErrorHandling：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// utils.js</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> foo</span><span style="color:#A6ACCD;">(fn) {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> callWithErrorHandling</span><span style="color:#A6ACCD;">(fn)</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#A6ACCD;">(fn) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">callWithErrorHandling</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">callWithErrorHandling</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fn</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">e</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">16</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，代码变得简洁多了。但简洁不是目的，这么做真正的 好处是，我们能为用户提供统一的错误处理接口，如以下代码所示：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// utils.js</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> handleError </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> foo</span><span style="color:#A6ACCD;">(fn) {</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> callWithErrorHandling</span><span style="color:#A6ACCD;">(fn)</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 用户可以调用该函数注册统一的错误处理函数</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">registerErrorHandler</span><span style="color:#A6ACCD;">(fn) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">handleError</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">callWithErrorHandling</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fn</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">e</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">16</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 将捕获到的错误传递给用户的错误处理程序</span></span>
<span class="line"><span style="color:#F78C6C;">17</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">handleError</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">18</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">19</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>我们提供了 registerErrorHandler 函数，用户可以使用它注 册错误处理程序，然后在 callWithErrorHandling 函数内部捕获 错误后，把错误传递给用户注册的错误处理程序。</p><p>这样用户侧的代码就会非常简洁且健壮：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> utils </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utils.js</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 注册错误处理程序</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> utils</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">registerErrorHandler</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> utils</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/*...*/</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> utils</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">bar</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/*...*/</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>这时错误处理的能力完全由用户控制，用户既可以选择忽略错 误，也可以调用上报程序将错误上报给监控系统。 实际上，这就是 Vue.js 错误处理的原理，你可以在源码中搜索到 callWithErrorHandling 函数。另外，在 Vue.js 中，我们也可以注 册统一的错误处理函数：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> App </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">App.vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createApp</span><span style="color:#A6ACCD;">(App)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> app</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">config</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">errorHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 错误处理程序</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><h2 id="_2-7-良好的-typescript-类型支持" tabindex="-1">2.7 良好的 TypeScript 类型支持 <a class="header-anchor" href="#_2-7-良好的-typescript-类型支持" aria-hidden="true">#</a></h2><p>TypeScript 是由微软开源的编程语言，简称 TS，它是 JavaScript 的 超集，能够为 JavaScript 提供类型支持。现在越来越多的开发者和团队 在项目中使用 TS。使用 TS 的好处有很多，如代码即文档、编辑器自 动提示、一定程度上能够避免低级 bug、代码的可维护性更强等。因此 对 TS 类型的支持是否完善也成为评价一个框架的重要指标。</p><p>如何衡量一个框架对 TS 类型支持的水平呢？这里有一个常见的误 区，很多读者以为只要是使用 TS 编写框架，就等价于对 TS 类型支持 友好，其实这是两件完全不同的事。考虑到有的读者可能没有接触过 TS，所以这里不会做深入讨论，我们只举一个简单的例子。下面是使 用 TS 编写的函数：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>这个函数很简单，它接收参数 val 并且该参数可以是任意类型 （any），该函数直接将参数作为返回值，这说明返回值的类型是由参 数决定的，如果参数是 number 类型，那么返回值也是 number 类 型。然后我们尝试使用一下这个函数，如图 2-5 所示。</p><p><img src="`+i+`" alt="image-20230413160247747"></p><p>在调用 foo 函数时，我们传递了一个字符串类型的参数 &#39;str&#39;， 按照之前的分析，得到的结果 res 的类型应该也是字符串类型，然而 当我们把鼠标指针悬浮到 res 常量上时，可以看到其类型是 any，这 并不是我们想要的结果。为了达到理想状态，我们只需要对 foo 函数 做简单的修改即可：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p><img src="`+A+'" alt="image-20230413160331381"></p><p>可以看到，res 的类型是字符字面量 &#39;str&#39; 而不是 any 了，这说 明我们的代码生效了。 通过这个简单的例子我们认识到，使用 TS 编写代码与对 TS 类型 支持友好是两件事。</p><p>在编写大型框架时，想要做到完善的 TS 类型支持 很不容易，大家可以查看 Vue.js 源码中的 runtimecore/src/apiDefineComponent.ts 文件，整个文件里真正会在浏览器中运 行的代码其实只有 3 行，但是全部的代码接近 200 行，其实这些代码 都是在为类型支持服务。由此可见，框架想要做到完善的类型支持， 需要付出相当大的努力。</p><p>除了要花大力气做类型推导，从而做到更好的类型支持外，还要 考虑对 TSX 的支持，后续章节会详细讨论这部分内容。</p><h2 id="_2-8-总结" tabindex="-1">2.8 总结 <a class="header-anchor" href="#_2-8-总结" aria-hidden="true">#</a></h2><ol><li><p>本章首先讲解了框架设计中关于开发体验的内容，开发体验是衡 量一个框架的重要指标之一。提供友好的警告信息至关重要，这有助 于开发者快速定位问题，因为大多数情况下“框架”要比开发者更清楚 问题出在哪里，因此在框架层面抛出有意义的警告信息是非常必要的。</p></li><li><p>但提供的警告信息越详细，就意味着框架体积越大。因此，为了 框架体积不受警告信息的影响，我们需要利用 Tree-Shaking 机制，配 合构建工具预定义常量的能力，例如预定义 <strong>DEV</strong> 常量，从而实现 仅在开发环境中打印警告信息，而生产环境中则不包含这些用于提升 开发体验的代码，从而实现线上代码体积的可控性。</p></li><li><p>Tree-Shaking 是一种排除 dead code 的机制，框架中会内建多种能 力，例如 Vue.js 内建的组件等。对于用户可能用不到的能力，我们可 以利用 Tree-Shaking 机制使最终打包的代码体积最小化。另外，TreeShaking 本身基于 ESM，并且 JavaScript 是一门动态语言，通过纯静态 分析的手段进行 Tree-Shaking 难度较大，因此大部分工具能够识别 /<em>#<strong>PURE</strong></em>/ 注释，在编写框架代码时，我们可以利用 /<em>#<strong>PURE</strong></em>/ 来辅助构建工具进行 Tree-Shaking。</p></li><li><p>接着我们讨论了框架的输出产物，不同类型的产物是为了满足不同的需求。为了让用户能够通过 script 标签直接引用并使用，我们需要输出 IIFE 格式的资源，即立即调用的函数表达式。为了让用户能够通过 script type=&quot;module&quot; 引用并使用，我们需要输出ESM 格式的资源。这里需要注意的是，ESM 格式的资源有两种：用于浏览器的 esm-browser.js 和用于打包工具的 esm-bundler.js。它们的区别在于对预定义常量 <strong>DEV</strong> 的处理，前者直接将 <strong>DEV</strong> 常量替换为字面量 true 或 false，后者则将 <strong>DEV</strong> 常量替换为p<wbr>rocess.env.NODE_ENV !== &#39;production&#39; 语句。</p></li><li><p>框架会提供多种能力或功能。有时出于灵活性和兼容性的考虑， 对于同样的任务，框架提供了两种解决方案，例如 Vue.js 中的选项对 象式 API 和组合式 API 都能用来完成页面的开发，两者虽然不互斥， 但从框架设计的角度看，这完全是基于兼容性考虑的。有时用户明确 知道自己仅会使用组合式 API，而不会使用选项对象式 API，这时用户 可以通过特性开关关闭对应的特性，这样在打包的时候，用于实现关 闭功能的代码将会被 Tree-Shaking 机制排除。</p></li><li><p>框架的错误处理做得好坏直接决定了用户应用程序的健壮性，同 时还决定了用户开发应用时处理错误的心智负担。框架需要为用户提 供统一的错误处理接口，这样用户可以通过注册自定义的错误处理函 数来处理全部的框架异常。</p></li><li><p>最后，我们点出了一个常见的认知误区，即“使用 TS 编写框架和 框架对 TS 类型支持友好是两件完全不同的事”。有时候为了让框架提 供更加友好的类型支持，甚至要花费比实现框架功能本身更多的时间 和精力。</p></li></ol>',196),g=[u];function h(v,m,b,f,E,j){return n(),a("div",null,g)}const k=s(d,[["render",h]]);export{S as __pageData,k as default};
