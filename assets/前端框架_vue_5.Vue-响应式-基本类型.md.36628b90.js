import{_ as s,c as n,o as a,e as l}from"./app.58766e8b.js";const i=JSON.parse('{"title":"第 6 章 原始值的响应式方案","description":"","frontmatter":{},"headers":[{"level":2,"title":"6.1 引入 ref 的概念","slug":"_6-1-引入-ref-的概念","link":"#_6-1-引入-ref-的概念","children":[]},{"level":2,"title":"6.2 响应丢失问题","slug":"_6-2-响应丢失问题","link":"#_6-2-响应丢失问题","children":[]},{"level":2,"title":"6.3 自动脱 ref","slug":"_6-3-自动脱-ref","link":"#_6-3-自动脱-ref","children":[]},{"level":2,"title":"6.4 总结","slug":"_6-4-总结","link":"#_6-4-总结","children":[]}],"relativePath":"前端框架/vue/5.Vue-响应式-基本类型.md"}'),p={name:"前端框架/vue/5.Vue-响应式-基本类型.md"},o=l(`<h1 id="第-6-章-原始值的响应式方案" tabindex="-1">第 6 章 原始值的响应式方案 <a class="header-anchor" href="#第-6-章-原始值的响应式方案" aria-hidden="true">#</a></h1><blockquote><p>在第 5 章中，我们讨论了非原始值的响应式方案，本章我们将讨 论原始值的响应式方案。原始值指的是 Boolean、Number、 BigInt、String、Symbol、undefined 和 null 等类型的值。在 JavaScript 中，原始值是按值传递的，而非按引用传递。这意味着，如 果一个函数接收原始值作为参数，那么形参与实参之间没有引用关 系，它们是两个完全独立的值，对形参的修改不会影响实参。另外， JavaScript 中的 Proxy 无法提供对原始值的代理，因此想要将原始值 变成响应式数据，就必须对其做一层包裹，也就是我们接下来要介绍 的 ref。</p></blockquote><h2 id="_6-1-引入-ref-的概念" tabindex="-1">6.1 引入 ref 的概念 <a class="header-anchor" href="#_6-1-引入-ref-的概念" aria-hidden="true">#</a></h2><p>由于 Proxy 的代理目标必须是非原始值，所以我们没有任何手段 拦截对原始值的操作，例如：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 无法拦截对值的修改</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue3</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div><p>对于这个问题，我们能够想到的唯一办法是，使用一个非原始值 去“包裹”原始值，例如使用一个对象包裹原始值：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> wrapper </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 可以使用 Proxy 代理 wrapper，间接实现对原始值的拦截</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(wrapper)</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#676E95;font-style:italic;">// vue</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 修改值可以触发响应</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue3</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div><p>但这样做会导致两个问题：</p><ul><li>用户为了创建一个响应式的原始值，不得不顺带创建一个包裹对 象；</li><li>包裹对象由用户定义，而这意味着不规范。用户可以随意命名， 例如 wrapper.value、wrapper.val 都是可以的。</li></ul><p>为了解决这两个问题，我们可以封装一个函数，将包裹对象的创 建工作都封装到该函数中：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 封装一个 ref 函数</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 在 ref 函数内部创建包裹对象</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 将包裹对象变成响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>如上面的代码所示，我们把创建 wrapper 对象的工作封装到 ref 函数内部，然后使用 reactive 函数将包裹对象变成响应式数据并返 回。这样我们就解决了上述两个问题。运行如下测试代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 创建原始值的响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> refVal </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">effect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 在副作用函数内通过 value 属性读取原始值</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">refVal</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 修改值能够触发副作用函数重新执行</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> refVal</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"></span></code></pre></div><p>上面这段代码能够按照预期工作。现在是否一切都完美了呢？并 不是，接下来我们面临的第一个问题是，如何区分 refVal 到底是原 始值的包裹对象，还是一个非原始值的响应式数据，如以下代码所 示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> refVal1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> refVal2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>思考一下，这段代码中的 refVal1 和 refVal2 有什么区别呢？ 从我们的实现来看，它们没有任何区别。但是，我们有必要区分一个 数据到底是不是 ref，因为这涉及下文讲解的自动脱 ref 能力。 想要区分一个数据是否是 ref 很简单，怎么做呢？如下面的代码 所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 使用 Object.defineProperty 在 wrapper 对象上定义一个不可枚举的属</span></span>
<span class="line"><span style="color:#A6ACCD;">性</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">__v_isRef</span><span style="color:#F07178;">，</span><span style="color:#A6ACCD;">并且值为</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">wrapper</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">__v_isRef</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">09</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>我们使用 Object.defineProperty 为包裹对象 wrapper 定义 了一个不可枚举且不可写的属性 __v_isRef，它的值为 true，代表 这个对象是一个 ref，而非普通对象。这样我们就可以通过检查 __v_isRef 属性来判断一个数据是否是 ref 了。</p><h2 id="_6-2-响应丢失问题" tabindex="-1">6.2 响应丢失问题 <a class="header-anchor" href="#_6-2-响应丢失问题" aria-hidden="true">#</a></h2><p>ref 除了能够用于原始值的响应式方案之外，还能用来解决响应 丢失问题。首先，我们来看什么是响应丢失问题。在编写 Vue.js 组件 时，我们通常要把数据暴露到模板中使用，例如：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> setup</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> const obj = reactive</span><span style="color:#A6ACCD;">({ </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">05</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 将数据暴露到模板中</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> ...obj</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span></code></pre></div><p>接着，我们就可以在模板中访问从 setup 中暴露出来的数据：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">{ foo </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">} </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#A6ACCD;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>然而，这么做会导致响应丢失。其表现是，当我们修改响应式数 据的值时，不会触发重新渲染：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> setup</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> const obj = reactive</span><span style="color:#A6ACCD;">({ </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">05</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 1s 后修改响应式数据的值，不会触发重新渲染</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">100</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">10</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> ...obj</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span></code></pre></div><p>为什么会导致响应丢失呢？这是由展开运算符（...）导致的。实 际上，下面这段代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> ...obj</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 等价于</span></span>
<span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以发现，这其实就是返回了一个普通对象，它不具有任何响应 式能力。把一个普通对象暴露到模板中使用，是不会在渲染函数与响 应式数据之间建立响应联系的。所以当我们尝试在一个定时器中修改 obj.foo 的值时，不会触发重新渲染。我们可以用另一种方式来描述 响应丢失问题：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// obj 是响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 将响应式数据展开到一个新的对象 newObj</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> ...obj</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">effect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 在副作用函数内通过新的对象 newObj 读取 foo 属性值</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">13</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 很显然，此时修改 obj.foo 并不会触发响应</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span></span>
<span class="line"></span></code></pre></div><p>如上面的代码所示，首先创建一个响应式的数据对象 obj，然后 使用展开运算符得到一个新的对象 newObj，它是一个普通对象，不具 有响应能力。这里的关键点在于，副作用函数内访问的是普通对象 newObj，它没有任何响应能力，所以当我们尝试修改 obj.foo 的值 时，不会触发副作用函数重新执行。</p><p>如何解决这个问题呢？换句话说，有没有办法能够帮助我们实 现：在副作用函数内，即使通过普通对象 newObj 来访问属性值，也 能够建立响应联系？其实是可以的，代码如下：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// obj 是响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// newObj 对象下具有与 obj 对象同名的属性，并且每个属性值都是一个对象，</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 该对象具有一个访问器属性 value，当读取 value 的值时，其实读取的是 obj对象下相应的属性值</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> get value</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> return obj.foo</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">12 bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">16 }</span></span>
<span class="line"><span style="color:#A6ACCD;">17 }</span></span>
<span class="line"><span style="color:#F78C6C;">18</span></span>
<span class="line"><span style="color:#F78C6C;">19</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">effect</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">20</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 在副作用函数内通过新的对象 newObj 读取 foo 属性值</span></span>
<span class="line"><span style="color:#F78C6C;">21</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">console</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">newObj</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">foo</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">value</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">22 })</span></span>
<span class="line"><span style="color:#F78C6C;">23</span></span>
<span class="line"><span style="color:#F78C6C;">24</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 这时能够触发响应了</span></span>
<span class="line"><span style="color:#F78C6C;">25</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">foo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>在上面这段代码中，我们修改了 newObj 对象的实现方式。可以 看到，在现在的 newObj 对象下，具有与 obj 对象同名的属性，而且 每个属性的值都是一个对象，例如 foo 属性的值是：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">get</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">value</span><span style="color:#F07178;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>该对象有一个访问器属性 value，当读取 value 的值时，最终读 取的是响应式数据 obj 下的同名属性值。也就是说，当在副作用函数 内读取 newObj.foo 时，等价于间接读取了 obj.foo 的值。这样响 应式数据自然能够与副作用函数建立响应联系。于是，当我们尝试修 改 obj.foo 的值时，能够触发副作用函数重新执行。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get value</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> return obj.foo</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">07 bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">11 }</span></span>
<span class="line"><span style="color:#A6ACCD;">12 }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>foo 和 bar 这两个属性的结构非常像，这启发我们将这种结构抽 象出来并封装成函数，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get value() {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> return obj[key]</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">07</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> wrapper</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>toRef 函数接收两个参数，第一个参数 obj 是一个响应式数据， 第二个参数是 obj 对象的一个键。该函数会返回一个类似于 ref 结构 的 wrapper 对象。有了 toRef 函数后，我们就可以重新实现 newObj 对象了：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">foo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，代码变得非常简洁。但如果响应式数据 obj 的键非常 多，我们还是要花费很大力气来做这一层转换。为此，我们可以封装 toRefs 函数，来批量地完成转换</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRefs</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ret</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 使用 for...in 循环遍历对象</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">in</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 逐个调用 toRef 完成转换</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ret</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ret</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>现在，我们只需要一步操作即可完成对一个对象的转换：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>可以使用如下代码进行测试：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">02</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"></span></code></pre></div><p>现在，响应丢失问题就被我们彻底解决了。解决问题的思路是， 将响应式数据转换成类似于 ref 结构的数据。但为了概念上的统一， 我们会将通过 toRef 或 toRefs 转换后得到的结果视为真正的 ref 数据，为此我们需要为 toRef 函数增加一段代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get value() {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> return obj[key]</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 定义 __v_isRef 属性</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(wrapper</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">__v_isRef</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">11</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> wrapper</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，我们使用 Object.defineProperty 函数为 wrapper 对象定义了 __v_isRef 属性。这样，toRef 函数的返回值 就是真正意义上的 ref 了。通过上述讲解我们能注意到，ref 的作用 不仅仅是实现原始值的响应式方案，它还用来解决响应丢失问题。 但上文中实现的 toRef 函数存在缺陷，即通过 toRef 函数创建 的 ref 是只读的，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get value() {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> return obj[key]</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">06 </span><span style="color:#676E95;font-style:italic;">// 允许设置值</span></span>
<span class="line"><span style="color:#F07178;">07 </span><span style="color:#A6ACCD;">set</span><span style="color:#F07178;"> value(val) {</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">11</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(wrapper</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">__v_isRef</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">15</span></span>
<span class="line"><span style="color:#F78C6C;">16</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> wrapper</span></span>
<span class="line"><span style="color:#F78C6C;">17</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，当设置 value 属性的值时，最终设置的是响应式数据 的同名属性的值，这样就能正确地触发响应了。</p><h2 id="_6-3-自动脱-ref" tabindex="-1">6.3 自动脱 ref <a class="header-anchor" href="#_6-3-自动脱-ref" aria-hidden="true">#</a></h2><p>toRefs 函数的确解决了响应丢失问题，但同时也带来了新的问 题。由于 toRefs 会把响应式数据的第一层属性值转换为 ref，因此 必须通过 value 属性访问值，如以下代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#F78C6C;">04</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 必须使用 value 访问值</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"></span></code></pre></div><p>这其实增加了用户的心智负担，因为通常情况下用户是在模板中 访问数据的，例如：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">{ foo </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">} </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>可以看到，即使 newObj.foo 是一个 ref，也无须通过 newObj.foo.value 来访问它的值。要实现此功能，需要使用 Proxy 为 newObj 创建一个代理对象，通过代理来实现最终目标，这 时就用到了上文中介绍的 ref 标识，即 __v_isRef 属性，如下面的 代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">proxyRefs</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> receiver) {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> const value = Reflect.get(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> receiver)</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 自动脱 ref 实现：如果读取的值是 ref，则返回它的 value 属性值</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> return value.__v_isRef ? value.value </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> })</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">10</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 调用 proxyRefs 函数创建代理</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">proxyRefs</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>在上面这段代码中，我们定义了 proxyRefs 函数，该函数接收 一个对象作为参数，并返回该对象的代理对象。代理对象的作用是拦 截 get 操作，当读取的属性是一个 ref 时，则直接返回该 ref 的 value 属性值，这样就实现了自动脱 ref：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar) </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"></span></code></pre></div><h2 id="_6-4-总结" tabindex="-1">6.4 总结 <a class="header-anchor" href="#_6-4-总结" aria-hidden="true">#</a></h2><ul><li>在本章中，我们首先介绍了 ref 的概念。ref 本质上是一个“包裹 对象”。因为 JavaScript 的 Proxy 无法提供对原始值的代理，所以我们 需要使用一层对象作为包裹，间接实现原始值的响应式方案。由于“包 裹对象”本质上与普通对象没有任何区别，因此为了区分 ref 与普通响 应式对象，我们还为“包裹对象”定义了一个值为 true 的属性，即 __v_isRef，用它作为 ref 的标识。</li><li>ref 除了能够用于原始值的响应式方案之外，还能用来解决响应 丢失问题。为了解决该问题，我们实现了 toRef 以及 toRefs 这两个 函数。它们本质上是对响应式数据做了一层包装，或者叫作“访问代 理”。</li><li>最后，我们讲解了自动脱 ref 的能力。为了减轻用户的心智负 担，我们自动对暴露到模板中的响应式数据进行脱 ref 处理。这样， 用户在模板中使用响应式数据时，就无须关心一个值是不是 ref 了。</li></ul>`,62),e=[o];function t(c,r,y,C,F,D){return a(),n("div",null,e)}const f=s(p,[["render",t]]);export{i as __pageData,f as default};
