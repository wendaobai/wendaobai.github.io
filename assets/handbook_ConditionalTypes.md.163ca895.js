import{_ as e,c as o,o as s,d as a}from"./app.e94b66cf.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"常见类型（Everyday Types）","slug":"常见类型-everyday-types","link":"#常见类型-everyday-types","children":[]},{"level":2,"title":"#原始类型: string，number 和 boolean（The primitives）","slug":"原始类型-string-number-和-boolean-the-primitives","link":"#原始类型-string-number-和-boolean-the-primitives","children":[]},{"level":2,"title":"#数组（Array）","slug":"数组-array","link":"#数组-array","children":[]},{"level":2,"title":"#any","slug":"any","link":"#any","children":[]}],"relativePath":"handbook/ConditionalTypes.md"}'),n={name:"handbook/ConditionalTypes.md"},l=a(`<h2 id="常见类型-everyday-types" tabindex="-1">常见类型（Everyday Types） <a class="header-anchor" href="#常见类型-everyday-types" aria-hidden="true">#</a></h2><p>本章我们会讲解 JavaScript 中最常见的一些类型，以及对应的描述方式。注意本章内容并不详尽，后续的章节会讲解更多命名和使用类型的方式。</p><p>类型可以出现在很多地方，不仅仅是在类型注解 (type annotations)中。我们不仅要学习类型本身，也要学习在什么地方使用这些类型产生新的结构。</p><p>我们先复习下最基本和常见的类型，这些是构建更复杂类型的基础。</p><h2 id="原始类型-string-number-和-boolean-the-primitives" tabindex="-1"><a href="https://ts.yayujs.com/handbook/EverydayType.html#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B-string-number-%E5%92%8C-boolean-the-primitives" target="_blank" rel="noreferrer">#</a>原始类型: <code>string</code>，<code>number</code> 和 <code>boolean</code>（The primitives） <a class="header-anchor" href="#原始类型-string-number-和-boolean-the-primitives" aria-hidden="true">#</a></h2><p>JavaScript 有三个非常常用的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noreferrer">原始类型 <strong>(opens new window)</strong></a>：<code>string</code>，<code>number</code> 和 <code>boolean</code>，每一个类型在 TypeScript 中都有对应的类型。他们的名字跟你在 JavaScript 中使用 <code>typeof</code> 操作符得到的结果是一样的。</p><ul><li><code>string</code> 表示字符串，比如 &quot;Hello, world&quot;</li><li><code>number</code> 表示数字，比如 <code>42</code>，JavaScript 中没有 <code>int</code> 或者 <code>float</code>，所有的数字，类型都是 <code>number</code></li><li><code>boolean</code> 表示布尔值，其实也就两个值： <code>true</code> 和 <code>false</code></li></ul><blockquote><p>类型名 <code>String</code> ，<code>Number</code> 和 <code>Boolean</code> （首字母大写）也是合法的，但它们是一些非常少见的特殊内置类型。所以类型总是使用 <code>string</code> ，<code>number</code> 或者 <code>boolean</code> 。</p></blockquote><h2 id="数组-array" tabindex="-1"><a href="https://ts.yayujs.com/handbook/EverydayType.html#%E6%95%B0%E7%BB%84-array" target="_blank" rel="noreferrer">#</a>数组（Array） <a class="header-anchor" href="#数组-array" aria-hidden="true">#</a></h2><p>声明一个类似于 <code>[1, 2, 3]</code> 的数组类型，你需要用到语法 <code>number[]</code>。这个语法可以适用于任何类型（举个例子，<code>string[]</code> 表示一个字符串数组）。你也可能看到这种写法 <code>Array&lt;number&gt;</code>，是一样的。我们会在泛型章节为大家介绍 <code>T&lt;U&gt;</code> 语法。</p><blockquote><p>注意 <code>[number]</code> 和 <code>number[]</code> 表示不同的意思，参考<a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types" target="_blank" rel="noreferrer">元组 <strong>(opens new window)</strong></a>章节</p></blockquote><h2 id="any" tabindex="-1"><a href="https://ts.yayujs.com/handbook/EverydayType.html#any" target="_blank" rel="noreferrer">#</a><code>any</code> <a class="header-anchor" href="#any" aria-hidden="true">#</a></h2><p>TypeScript 有一个特殊的类型，<code>any</code>，当你不希望一个值导致类型检查错误的时候，就可以设置为 <code>any</code> 。</p><p>当一个值是 <code>any</code> 类型的时候，你可以获取它的任意属性 (也会被转为 <code>any</code> 类型)，或者像函数一样调用它，把它赋值给一个任意类型的值，或者把任意类型的值赋值给它，再或者是其他语法正确的操作，都可以：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">x</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// None of the following lines of code will throw compiler errors.</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Using \`any\` disables all further type checking, and it is assumed </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// you know the environment better than TypeScript.</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">obj</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> n</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>复制代码</p><p>当你不想写一个长长的类型代码，仅仅想让 TypeScript 知道某段特定的代码是没有问题的，<code>any</code> 类型是很有用的。</p>`,17),t=[l];function r(p,c,d,i,y,h){return s(),o("div",null,t)}const C=e(n,[["render",r]]);export{D as __pageData,C as default};
