import{_ as e,c as l,o as i,e as a}from"./app.1c8695ff.js";const t="/assets/image-20230324101555740.647e1d56.png",s="/assets/image-20230324103502685.3afcd25b.png",c="/assets/image-20230324105210341.cb65a4c1.png",p="/assets/image-20230324110018306.5973844e.png",r="/assets/image-20230324110153104.9ac4a230.png",o="/assets/image-20230324110303555.91cd90e1.png",n="/assets/image-20230324111457523.0ae86342.png",N=JSON.parse('{"title":"TCP协议","description":"","frontmatter":{},"headers":[{"level":2,"title":"TCP的数据格式","slug":"tcp的数据格式","link":"#tcp的数据格式","children":[]},{"level":2,"title":"建立连接，三次握手","slug":"建立连接-三次握手","link":"#建立连接-三次握手","children":[]},{"level":2,"title":"传输数据","slug":"传输数据","link":"#传输数据","children":[]},{"level":2,"title":"断开连接，四次挥手","slug":"断开连接-四次挥手","link":"#断开连接-四次挥手","children":[]},{"level":2,"title":"常见面试题","slug":"常见面试题","link":"#常见面试题","children":[]}],"relativePath":"网络/tcp.md"}'),d={name:"网络/tcp.md"},h=a('<h1 id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-hidden="true">#</a></h1><h2 id="tcp的数据格式" tabindex="-1">TCP的数据格式 <a class="header-anchor" href="#tcp的数据格式" aria-hidden="true">#</a></h2><p><img src="'+t+'" alt="image-20230324101555740"></p><ul><li><p>源端口号和目标端口号</p><p>计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收</p></li><li><p>seq序列号</p><p>32位序列号 TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值</p></li><li><p>ack 确认号</p><p>确认应答号 它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。</p></li><li><p>首部长度：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。</p></li><li><p>标志位,即控制位,TCP的连接、传输和断开都受这六个控制位的指挥</p><ul><li>PSH(push急迫位) 缓存区将满，立刻传输速度</li><li>RST(reset重置位) 连接断了重新连接</li><li>URG(urgent紧急位) 紧急信号</li><li>ACK(acknowledgement 确认位)为1表示确认号</li><li>SYN(synchronous 连接位) 同步序号位 TCP建立连接时要将这个值设为1</li><li>FIN（终止位）发送端完成位，提出断开连接的一方把FIN置为1表示要断开连接</li></ul></li><li><p>窗口值 说明本地可接收数据段的数目，这个值的大小是可变的。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以保证网络数据的可靠传输。它是来在TCP传输中进行流量控制的</p></li><li><p>窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测。</p></li><li><p>效验和: 用来做差错控制，TCP校验和的计算包括TCP首部、数据和其它填充字节。在发送TCP数据段时，由发送端计算校验和，当到达目的地时又进行一次检验和计算。如果两次校验 和一致说明数据是正确的，否则 将认为数据被破坏，接收端将丢弃该数据</p></li><li><p>紧急指针：尽在 URG(urgent紧急) 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。</p></li></ul><h2 id="建立连接-三次握手" tabindex="-1">建立连接，三次握手 <a class="header-anchor" href="#建立连接-三次握手" aria-hidden="true">#</a></h2><ul><li>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接</li><li>在TCP/IP协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号，并确认双方tcp窗口的大小等信息</li></ul><p><img src="'+s+'" alt="image-20230324103502685"></p><h4 id="过程" tabindex="-1">过程 <a class="header-anchor" href="#过程" aria-hidden="true">#</a></h4><ul><li><p>第一次握手: 建立连接。客户端发送连接请求，发送<code>SYN</code>报文，将<code>seq</code>设置为0。然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认。</p><blockquote><p>client:【SYN】,Seq =x; 状态:SYN_SEND建立连接已发送</p></blockquote></li><li><p>第二次握手: 服务器收到客户端的SYN报文段。需要对这个SYN报文段进行确认，发送ACK报文，将ack设置为1。同时，自己还要发送SYN请求信息，将seq为0。服务器端将上述所有信息一并发送给客户端，此时服务器进入SYN_RECV状态。</p><blockquote><p>server:【SYN,ACK】,seq=y,ack=x+1; 状态:listen=&gt;SYN_RCVD，监听=》建立请求已经接收</p></blockquote></li><li><p>客户端收到服务器的ACK和SYN报文后，进行确认，然后将ack设置为1，seq设置为1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手</p><blockquote><p>client:【ACK】,ack=y+1,seq=x+1 状态：SYN_SEND=&gt;ESTABLISHED,建立请求发送=》连接已经建立</p></blockquote></li></ul><h4 id="数据抓包" tabindex="-1">数据抓包 <a class="header-anchor" href="#数据抓包" aria-hidden="true">#</a></h4><p><img src="'+c+'" alt="image-20230324105210341"></p><h2 id="传输数据" tabindex="-1">传输数据 <a class="header-anchor" href="#传输数据" aria-hidden="true">#</a></h2><p><img src="'+p+'" alt="image-20230324110018306"></p><ul><li>客户端先向服务器发送数据，该数据报是长度为159的数据。</li><li>服务器收到报文后, 也向客户端发送了一个数据进行确认（ACK），并且返回客户端要请求的数据，数据的长度为111，将seq设置为1，ack设置为160（1 + 159）。</li><li>客户端收到服务器返回的数据后进行确认（ACK），将seq设置为160， ack设置为112（1 + 111）。</li></ul><h2 id="断开连接-四次挥手" tabindex="-1">断开连接，四次挥手 <a class="header-anchor" href="#断开连接-四次挥手" aria-hidden="true">#</a></h2><p><img src="'+r+'" alt="image-20230324110153104"></p><img src="'+o+'" alt="image-20230324110303555" style="zoom:50%;"><ul><li><p>第一次挥手：客户端向服务器发送一个FIN报文段，将设置seq为160和ack为112，;此时，客户端进入 FIN_WAIT_1状态,这表示客户端没有数据要发送服务器了，请求关闭连接;</p><blockquote><p>client:[ACK,FIN]seq=x,ack=y,状态：ESTABLISHED=&gt;FIN_WAIT_1</p></blockquote></li><li><p>第二次挥手：服务器收到了客户端发送的FIN报文段，向客户端回一个ACK报文段，ack设置为1，seq设置为112;服务器进入了CLOSE_WAIT状态，客户端收到服务器返回的ACK报文后，进入FIN_WAIT_2状态;</p><blockquote><p>server:[ACK]ack=x+1,seq=y,状态：ESTABLISHED=&gt;CLOSE_WAIT</p></blockquote></li><li><p>第三次挥手：服务器会观察自己是否还有数据没有发送给客户端，如果有，先把数据发送给客户端，再发送FIN报文；如果没有，那么服务器直接发送FIN报文给客户端。请求关闭连接，同时服务器进入LAST_ACK状态;</p><blockquote><p>server:[FIN,ACK]seq=y,ack=x+1,状态：CLOSE_WAIT=&gt;LAST_ACK</p></blockquote></li><li><p>第四次挥手：客户端收到服务器发送的FIN报文段，向服务器发送ACK报文段，将seq设置为161，将ack设置为113，然后客户端进入TIME_WAIT状态;服务器收到客户端的ACK报文段以后，就关闭连接;此时，客户端等待2MSL后依然没有收到回复，则证明Server端已正常关闭，客户端也可以关闭连接了。</p><blockquote><p>【ACK】ack=y+1;seq=x+1 状态：closed</p></blockquote></li></ul><p><img src="'+n+'" alt="image-20230324111457523"></p><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>注意：在握手和挥手时确认号应该是对方序列号加1,传输数据时则是对方序列号加上对方携带应用层数据的长度</p></div><h2 id="常见面试题" tabindex="-1">常见面试题 <a class="header-anchor" href="#常见面试题" aria-hidden="true">#</a></h2><ol><li>为什么需要三次握手? 确保双方收发都是正常的</li><li>为什么需要四次挥手? 双方数据发送完毕，都认为可以断开</li><li>为什么需要等待? A向B发的<code>FIN</code>可能丢失</li><li>为什么握手是三次，但挥手却是四次? 当Server端收到FIN报文时，很可能并不会立即关闭SOCKET</li></ol>',22),_=[h];function u(C,g,S,m,T,k){return i(),l("div",null,_)}const q=e(d,[["render",u]]);export{N as __pageData,q as default};
