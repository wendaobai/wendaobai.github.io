import{_ as s,c as n,o as a,e as l}from"./app.58766e8b.js";const i=JSON.parse('{"title":"第 12 章 组件的实现原理","description":"","frontmatter":{},"headers":[{"level":2,"title":"12.1 渲染组件","slug":"_12-1-渲染组件","link":"#_12-1-渲染组件","children":[]},{"level":2,"title":"12.2 组件状态与自更新","slug":"_12-2-组件状态与自更新","link":"#_12-2-组件状态与自更新","children":[]},{"level":2,"title":"12.3 组件实例与组件的生命周期","slug":"_12-3-组件实例与组件的生命周期","link":"#_12-3-组件实例与组件的生命周期","children":[]}],"relativePath":"前端框架/vue/11.Vue-组件实现原理.md"}'),p={name:"前端框架/vue/11.Vue-组件实现原理.md"},o=l(`<h1 id="第-12-章-组件的实现原理" tabindex="-1">第 12 章 组件的实现原理 <a class="header-anchor" href="#第-12-章-组件的实现原理" aria-hidden="true">#</a></h1><blockquote><p>在上一篇中，我们着重讲解了渲染器的基本原理与实现。渲染器 主要负责将虚拟 DOM 渲染为真实 DOM，我们只需要使用虚拟 DOM 来描述最终呈现的内容即可。但当我们编写比较复杂的页面时，用来 描述页面结构的虚拟 DOM 的代码量会变得越来越多，或者说页面模板 会变得越来越大。这时，我们就需要组件化的能力。有了组件，我们 就可以将一个大的页面拆分为多个部分，每一个部分都可以作为单独 的组件，这些组件共同组成完整的页面。组件化的实现同样需要渲染 器的支持，从本章开始，我们将详细讨论 Vue.js 中的组件化。</p></blockquote><h2 id="_12-1-渲染组件" tabindex="-1">12.1 渲染组件 <a class="header-anchor" href="#_12-1-渲染组件" aria-hidden="true">#</a></h2><p>从用户的角度来看，一个有状态组件就是一个选项对象，如下面 的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// MyComponent 是一个组件，它的值是一个选项对象</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyComponent</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> data</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> return { foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span></code></pre></div><p>但是，如果从渲染器的内部实现来看，一个组件则是一个特殊类 型的虚拟 DOM 节点。例如，为了描述普通标签，我们用虚拟节点的 vnode.type 属性来存储标签名称，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 该 vnode 用来描述组件，type 属性存储组件的选项对象</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> vnode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> MyComponent</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>为了让渲染器能够处理组件类型的虚拟节点，我们还需要在 patch 函数中对组件类型的虚拟节点进行处理，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">patch</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">n1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">n2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">container</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">anchor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">n1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">unmount</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">n1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">n1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">string</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 作为普通元素处理</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Text</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 作为文本节点处理</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Fragment</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 作为片段处理</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">object</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// vnode.type 的值是选项对象，作为组件来处理</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">n1</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 挂载组件</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">mountComponent</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">n2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 更新组件</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">patchComponent</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">n1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>在上面这段代码中，我们新增了一个 else if 分支，用来处理虚 拟节点的 vnode.type 属性值为对象的情况，即将该虚拟节点作为组 件的描述来看待，并调用 mountComponent 和 patchComponent 函 数来完成组件的挂载和更新。</p><p>渲染器有能力处理组件后，下一步我们要做的是，设计组件在用 户层面的接口。这包括：用户应该如何编写组件？组件的选项对象必 须包含哪些内容？以及组件拥有哪些能力？等等。实际上，组件本身 是对页面内容的封装，它用来描述页面内容的一部分。因此，一个组 件必须包含一个渲染函数，即 render 函数，并且渲染函数的返回值 应该是虚拟 DOM。换句话说，组件的渲染函数就是用来描述组件所渲 染内容的接口，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 组件名称，可选</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyComponent</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 组件的渲染函数，其返回值必须为虚拟 DOM</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> render</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 返回虚拟 DOM</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> return {</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">我是文本内容</span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>这是一个最简单的组件示例。有了基本的组件结构之后，渲染器 就可以完成组件的渲染，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 用来描述组件的 VNode 对象，type 属性值为组件的选项对象</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> CompVNode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> MyComponent</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 调用渲染器来渲染组件</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> renderer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(CompVNode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span></span>
<span class="line"></span></code></pre></div><p>渲染器中真正完成组件渲染任务的是 mountComponent 函数， 其具体实现如下所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">mountComponent</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">vnode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">container</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">anchor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 通过 vnode 获取组件的选项对象，即 vnode.type</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">vnode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 获取组件的渲染函数 render</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">render</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 执行渲染函数，获取组件要渲染的内容，即 render 函数返回的虚拟 DOM</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subTree</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">render</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 最后调用 patch 函数来挂载组件所描述的内容，即 subTree</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">patch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">null,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subTree</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="_12-2-组件状态与自更新" tabindex="-1">12.2 组件状态与自更新 <a class="header-anchor" href="#_12-2-组件状态与自更新" aria-hidden="true">#</a></h2><p>在上一节中，我们完成了组件的初始渲染。接下来，我们尝试为 组件设计自身的状态，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">MyComponent</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 用 data 函数来定义组件自身的状态</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> data</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> return {</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello world</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> }</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> children</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">foo 的值是: </span><span style="color:#89DDFF;">\${</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">}\`</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 在渲染函数内使用组件状态</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span></code></pre></div><p>在上面这段代码中，我们约定用户必须使用 data 函数来定义组 件自身的状态，同时可以在渲染函数中通过 this 访问由 data 函数返 回的状态数据。 下面的代码实现了组件自身状态的初始化：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">mountComponent</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">vnode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">container</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">anchor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">vnode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">render</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span></span>
<span class="line"><span style="color:#F78C6C;">04</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 调用 data 函数得到原始数据，并调用 reactive 函数将其包装为响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#82AAFF;">data</span><span style="color:#F07178;">())</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 调用 render 函数时，将其 this 设置为 state，</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 从而 render 函数内部可以通过 this 访问组件自身状态数据</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subTree</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">render</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">patch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">null,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subTree</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>如上面的代码所示，实现组件自身状态的初始化需要两个步骤：</p><ul><li>通过组件的选项对象取得 data 函数并执行，然后调用 reactive 函数将 data 函数返回的状态包装为响应式数据；</li><li>在调用 render 函数时，将其 this 的指向设置为响应式数据 state，同时将 state 作为 render 函数的第一个参数传递</li></ul><p>经过上述两步工作后，我们就实现了对组件自身状态的支持，以 及在渲染函数内访问组件自身状态的能力。 当组件自身状态发生变化时，我们需要有能力触发组件更新，即 组件的自更新。为此，我们需要将整个渲染任务包装到一个 effect 中，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">mountComponent</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">vnode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">container</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">anchor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">vnode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">render</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span></span>
<span class="line"><span style="color:#F78C6C;">04</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#82AAFF;">data</span><span style="color:#F07178;">())</span></span>
<span class="line"><span style="color:#F78C6C;">06</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 将组件的 render 函数调用包装到 effect 内</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">effect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subTree</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">render</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">patch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">null,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subTree</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这样，一旦组件自身的响应式数据发生变化，组件就会自动重新 执行渲染函数，从而完成更新。但是，由于 effect 的执行是同步 的，因此当响应式数据发生变化时，与之关联的副作用函数会同步执 行。换句话说，如果多次修改响应式数据的值，将会导致渲染函数执 行多次，这实际上是没有必要的。因此，我们需要设计一个机制，以 使得无论对响应式数据进行多少次修改，副作用函数都只会重新执行 一次。为此，我们需要实现一个调度器，当副作用函数需要重新执行 时，我们不会立即执行它，而是将它缓冲到一个微任务队列中，等到 执行栈清空后，再将它从微任务队列中取出并执行。有了缓存机制， 我们就有机会对任务进行去重，从而避免多次执行副作用函数带来的 性能开销。具体实现如下：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 任务缓存队列，用一个 Set 数据结构来表示，这样就可以自动对任务进行去重</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> queue </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Set</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 一个标志，代表是否正在刷新任务队列</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> isFlushing </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 创建一个立即 resolve 的 Promise 实例</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> p </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#F78C6C;">07</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 调度器的主要函数，用来将一个任务添加到缓冲队列中，并开始刷新队列</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">queueJob</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">job</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 将 job 添加到任务队列 queue 中</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">job</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 如果还没有开始刷新队列，则刷新之</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">isFlushing</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 将该标志设置为 true 以避免重复刷新</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isFlushing</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">16</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 在微任务中刷新缓冲队列</span></span>
<span class="line"><span style="color:#F78C6C;">17</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">18</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">19</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 执行任务队列中的任务</span></span>
<span class="line"><span style="color:#F78C6C;">20</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">job</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">job</span><span style="color:#F07178;">())</span></span>
<span class="line"><span style="color:#F78C6C;">21</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">22</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 重置状态</span></span>
<span class="line"><span style="color:#F78C6C;">23</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isFlushing</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#F78C6C;">24</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">clear</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#F78C6C;">25</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">26</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">27</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">28</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>上面是调度器的最小实现，本质上利用了微任务的异步执行机 制，实现对副作用函数的缓冲。其中 queueJob 函数是调度器最主要 的函数，用来将一个任务或副作用函数添加到缓冲队列中，并开始刷 新队列。有了 queueJob 函数之后，我们可以在创建渲染副作用时使 用它，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">mountComponent</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">vnode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">container</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">anchor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">vnode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">render</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">componentOptions</span></span>
<span class="line"><span style="color:#F78C6C;">04</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#82AAFF;">data</span><span style="color:#F07178;">())</span></span>
<span class="line"><span style="color:#F78C6C;">06</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">effect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subTree</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">render</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">patch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">null,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">subTree</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 指定该副作用函数的调度器为 queueJob 即可</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> scheduler</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">queueJob</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>这样，当响应式数据发生变化时，副作用函数不会立即同步执 行，而是会被 queueJob 函数调度，最后在一个微任务中执行。</p><p>不过，上面这段代码存在缺陷。可以看到，我们在 effect 函数 内调用 patch 函数完成渲染时，第一个参数总是 null。这意味着， 每次更新发生时都会进行全新的挂载，而不会打补丁，这是不正确 的。正确的做法是：每次更新时，都拿新的 subTree 与上一次组件所 渲染的 subTree 进行打补丁。为此，我们需要实现组件实例，用它来 维护组件整个生命周期的状态，这样渲染器才能够在正确的时机执行 合适的操作</p><h2 id="_12-3-组件实例与组件的生命周期" tabindex="-1">12.3 组件实例与组件的生命周期 <a class="header-anchor" href="#_12-3-组件实例与组件的生命周期" aria-hidden="true">#</a></h2>`,32),e=[o];function t(c,r,y,F,C,D){return a(),n("div",null,e)}const d=s(p,[["render",t]]);export{i as __pageData,d as default};
