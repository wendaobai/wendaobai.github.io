<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 6 章 原始值的响应式方案 | Create or coding</title>
    <meta name="description" content="A VitePress site">
    <link rel="preload stylesheet" href="/assets/style.ae1251fb.css" as="style">
    <link rel="modulepreload" href="/assets/app.58766e8b.js">
    <link rel="modulepreload" href="/assets/前端框架_vue_5.Vue-响应式-基本类型.md.36628b90.lean.js">
    
    <script>var _hmt=_hmt||[];(function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?af110c84612806edd3af36a0678759fb";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-93a960b4><!--[--><!--]--><!--[--><span tabindex="-1" data-v-151f2593></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-151f2593> Skip to content </a><!--]--><!----><header class="VPNav" data-v-93a960b4 data-v-0fa0e57d><div class="VPNavBar has-sidebar" data-v-0fa0e57d data-v-be450ad9><div class="container" data-v-be450ad9><div class="title" data-v-be450ad9><div class="VPNavBarTitle has-sidebar" data-v-be450ad9 data-v-6d2fb2d9><a class="title" href="/" data-v-6d2fb2d9><!--[--><!--]--><!----><!--[-->Code More Create<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-be450ad9><div class="curtain" data-v-be450ad9></div><div class="content-body" data-v-be450ad9><!--[--><!--]--><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-be450ad9 data-v-bdedfc22><span id="main-nav-aria-label" class="visually-hidden" data-v-bdedfc22>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-bdedfc22 data-v-96001b6b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-96001b6b><span class="text" data-v-96001b6b><!----> js <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-96001b6b><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-96001b6b><div class="VPMenu" data-v-96001b6b data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/js/es6/1.let%E5%92%8Cconst%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->es6<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/js/interview/1.%E5%AE%9E%E7%8E%B0new%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->interview<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/js/%E5%9F%BA%E7%A1%80/1.%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->基础<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-bdedfc22 data-v-96001b6b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-96001b6b><span class="text" data-v-96001b6b><!----> 前端框架 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-96001b6b><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-96001b6b><div class="VPMenu" data-v-96001b6b data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/1.Vue-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%B4%A0.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->vue<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-bdedfc22 data-v-96001b6b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-96001b6b><span class="text" data-v-96001b6b><!----> 前端运维 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-96001b6b><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-96001b6b><div class="VPMenu" data-v-96001b6b data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E5%89%8D%E7%AB%AF%E8%BF%90%E7%BB%B4/CICD.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->CICD<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E5%89%8D%E7%AB%AF%E8%BF%90%E7%BB%B4/docker.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->docker<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E5%89%8D%E7%AB%AF%E8%BF%90%E7%BB%B4/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->linux常见命令<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E5%89%8D%E7%AB%AF%E8%BF%90%E7%BB%B4/nginx.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->nginx<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E5%89%8D%E7%AB%AF%E8%BF%90%E7%BB%B4/vim.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->vim<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-bdedfc22 data-v-96001b6b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-96001b6b><span class="text" data-v-96001b6b><!----> 网络 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-96001b6b><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-96001b6b><div class="VPMenu" data-v-96001b6b data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E7%BD%91%E7%BB%9C/http.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->http<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E7%BD%91%E7%BB%9C/https.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->https<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-a5bbb52c><a class="VPLink link" href="/%E7%BD%91%E7%BB%9C/tcp.html" data-v-a5bbb52c data-v-30c06bd3><!--[-->tcp<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/README.html" data-v-bdedfc22 data-v-95f5d58b data-v-30c06bd3><!--[-->README<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="https://algorithm.wendaobai.top" target="_blank" rel="noreferrer" data-v-bdedfc22 data-v-95f5d58b data-v-30c06bd3><!--[-->🏄🏻‍♂️ 算法笔记<!--]--><!----></a><!--]--><!--]--></nav><!----><!----><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-be450ad9 data-v-2ab2a029 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/wendaobai" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-be450ad9 data-v-66bb1f24 data-v-96001b6b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-96001b6b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-96001b6b><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-96001b6b><div class="VPMenu" data-v-96001b6b data-v-e7ea1737><!----><!--[--><!--[--><!----><!----><div class="group" data-v-66bb1f24><div class="item social-links" data-v-66bb1f24><div class="VPSocialLinks social-links-list" data-v-66bb1f24 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/wendaobai" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-be450ad9 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav" data-v-93a960b4 data-v-2817d72e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2817d72e><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-2817d72e><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-2817d72e>Menu</span></button><a class="top-link" href="#" data-v-2817d72e>Return to top</a></div><aside class="VPSidebar" data-v-93a960b4 data-v-c79ccefa><div class="curtain" data-v-c79ccefa></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-c79ccefa><span class="visually-hidden" id="sidebar-aria-label" data-v-c79ccefa> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-c79ccefa><section class="VPSidebarItem level-0 collapsible has-active" data-v-c79ccefa data-v-b05232f3><div class="item" role="button" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link" data-v-b05232f3 data-v-30c06bd3><!--[--><h2 class="text" data-v-b05232f3>前端框架</h2><!--]--><!----></a><div class="caret" role="button" data-v-b05232f3><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-b05232f3><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-b05232f3><!--[--><section class="VPSidebarItem level-1 collapsible has-active" data-v-b05232f3 data-v-b05232f3><div class="item" role="button" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link" data-v-b05232f3 data-v-30c06bd3><!--[--><h3 class="text" data-v-b05232f3>vue</h3><!--]--><!----></a><div class="caret" role="button" data-v-b05232f3><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="caret-icon" data-v-b05232f3><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z"></path></svg></div></div><div class="items" data-v-b05232f3><!--[--><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/1.Vue-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%B4%A0.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>1.Vue-框架设计要素</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/10.Vue-%E5%BF%AB%E9%80%9Fdiff%E7%AE%97%E6%B3%95.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>10.Vue-快速diff算法</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/11.Vue-%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>11.Vue-组件实现原理</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/2.Vue-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>2.Vue-框架设计思路</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/3.Vue-%E5%93%8D%E5%BA%94%E5%BC%8F-%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>3.Vue-响应式-基础实现</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/4.Vue-%E5%93%8D%E5%BA%94%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>4.Vue-响应式-对象实现</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link is-active has-active" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/5.Vue-%E5%93%8D%E5%BA%94%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>5.Vue-响应式-基本类型</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/6.Vue-%E6%B8%B2%E6%9F%93%E5%99%A8%E8%AE%BE%E8%AE%A1.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>6.Vue-渲染器设计</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/7.Vue-%E6%8C%82%E8%BD%BD%E4%B8%8E%E6%9B%B4%E6%96%B0.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>7.Vue-挂载与更新</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/8.Vue-%E7%AE%80%E5%8D%95diff.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>8.Vue-简单diff</p><!--]--><!----></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-b05232f3 data-v-b05232f3><div class="item" data-v-b05232f3><div class="indicator" data-v-b05232f3></div><a class="VPLink link link" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/9.Vue-%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95.html" data-v-b05232f3 data-v-30c06bd3><!--[--><p class="text" data-v-b05232f3>9.Vue-双端diff算法</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-93a960b4 data-v-0bd490fb><div class="VPDoc has-sidebar has-aside" data-v-0bd490fb data-v-c5936a1e><div class="container" data-v-c5936a1e><div class="aside" data-v-c5936a1e><div class="aside-curtain" data-v-c5936a1e></div><div class="aside-container" data-v-c5936a1e><div class="aside-content" data-v-c5936a1e><div class="VPDocAside" data-v-c5936a1e data-v-cdc66372><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-cdc66372 data-v-5dd9d5f6><div class="content" data-v-5dd9d5f6><div class="outline-marker" data-v-5dd9d5f6></div><div class="outline-title" data-v-5dd9d5f6>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-5dd9d5f6><span class="visually-hidden" id="doc-outline-aria-label" data-v-5dd9d5f6> Table of Contents for current page </span><ul class="root" data-v-5dd9d5f6 data-v-1188541a><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-cdc66372></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-c5936a1e><div class="content-container" data-v-c5936a1e><!--[--><!--]--><main class="main" data-v-c5936a1e><div style="position:relative;" class="vp-doc _%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6_vue_5_Vue-%E5%93%8D%E5%BA%94%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B" data-v-c5936a1e><div><h1 id="第-6-章-原始值的响应式方案" tabindex="-1">第 6 章 原始值的响应式方案 <a class="header-anchor" href="#第-6-章-原始值的响应式方案" aria-hidden="true">#</a></h1><blockquote><p>在第 5 章中，我们讨论了非原始值的响应式方案，本章我们将讨 论原始值的响应式方案。原始值指的是 Boolean、Number、 BigInt、String、Symbol、undefined 和 null 等类型的值。在 JavaScript 中，原始值是按值传递的，而非按引用传递。这意味着，如 果一个函数接收原始值作为参数，那么形参与实参之间没有引用关 系，它们是两个完全独立的值，对形参的修改不会影响实参。另外， JavaScript 中的 Proxy 无法提供对原始值的代理，因此想要将原始值 变成响应式数据，就必须对其做一层包裹，也就是我们接下来要介绍 的 ref。</p></blockquote><h2 id="_6-1-引入-ref-的概念" tabindex="-1">6.1 引入 ref 的概念 <a class="header-anchor" href="#_6-1-引入-ref-的概念" aria-hidden="true">#</a></h2><p>由于 Proxy 的代理目标必须是非原始值，所以我们没有任何手段 拦截对原始值的操作，例如：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 无法拦截对值的修改</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue3</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div><p>对于这个问题，我们能够想到的唯一办法是，使用一个非原始值 去“包裹”原始值，例如使用一个对象包裹原始值：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> wrapper </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 可以使用 Proxy 代理 wrapper，间接实现对原始值的拦截</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(wrapper)</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#676E95;font-style:italic;">// vue</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 修改值可以触发响应</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue3</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div><p>但这样做会导致两个问题：</p><ul><li>用户为了创建一个响应式的原始值，不得不顺带创建一个包裹对 象；</li><li>包裹对象由用户定义，而这意味着不规范。用户可以随意命名， 例如 wrapper.value、wrapper.val 都是可以的。</li></ul><p>为了解决这两个问题，我们可以封装一个函数，将包裹对象的创 建工作都封装到该函数中：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 封装一个 ref 函数</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 在 ref 函数内部创建包裹对象</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 将包裹对象变成响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>如上面的代码所示，我们把创建 wrapper 对象的工作封装到 ref 函数内部，然后使用 reactive 函数将包裹对象变成响应式数据并返 回。这样我们就解决了上述两个问题。运行如下测试代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 创建原始值的响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> refVal </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">effect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 在副作用函数内通过 value 属性读取原始值</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">refVal</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 修改值能够触发副作用函数重新执行</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> refVal</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"></span></code></pre></div><p>上面这段代码能够按照预期工作。现在是否一切都完美了呢？并 不是，接下来我们面临的第一个问题是，如何区分 refVal 到底是原 始值的包裹对象，还是一个非原始值的响应式数据，如以下代码所 示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> refVal1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> refVal2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>思考一下，这段代码中的 refVal1 和 refVal2 有什么区别呢？ 从我们的实现来看，它们没有任何区别。但是，我们有必要区分一个 数据到底是不是 ref，因为这涉及下文讲解的自动脱 ref 能力。 想要区分一个数据是否是 ref 很简单，怎么做呢？如下面的代码 所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 使用 Object.defineProperty 在 wrapper 对象上定义一个不可枚举的属</span></span>
<span class="line"><span style="color:#A6ACCD;">性</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">__v_isRef</span><span style="color:#F07178;">，</span><span style="color:#A6ACCD;">并且值为</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">wrapper</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">__v_isRef</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">09</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>我们使用 Object.defineProperty 为包裹对象 wrapper 定义 了一个不可枚举且不可写的属性 __v_isRef，它的值为 true，代表 这个对象是一个 ref，而非普通对象。这样我们就可以通过检查 __v_isRef 属性来判断一个数据是否是 ref 了。</p><h2 id="_6-2-响应丢失问题" tabindex="-1">6.2 响应丢失问题 <a class="header-anchor" href="#_6-2-响应丢失问题" aria-hidden="true">#</a></h2><p>ref 除了能够用于原始值的响应式方案之外，还能用来解决响应 丢失问题。首先，我们来看什么是响应丢失问题。在编写 Vue.js 组件 时，我们通常要把数据暴露到模板中使用，例如：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> setup</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> const obj = reactive</span><span style="color:#A6ACCD;">({ </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">05</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 将数据暴露到模板中</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> ...obj</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span></code></pre></div><p>接着，我们就可以在模板中访问从 setup 中暴露出来的数据：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">{ foo </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">} </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#A6ACCD;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>然而，这么做会导致响应丢失。其表现是，当我们修改响应式数 据的值时，不会触发重新渲染：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> setup</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> const obj = reactive</span><span style="color:#A6ACCD;">({ </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">05</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 1s 后修改响应式数据的值，不会触发重新渲染</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">100</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">10</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> ...obj</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span></code></pre></div><p>为什么会导致响应丢失呢？这是由展开运算符（...）导致的。实 际上，下面这段代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> ...obj</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 等价于</span></span>
<span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以发现，这其实就是返回了一个普通对象，它不具有任何响应 式能力。把一个普通对象暴露到模板中使用，是不会在渲染函数与响 应式数据之间建立响应联系的。所以当我们尝试在一个定时器中修改 obj.foo 的值时，不会触发重新渲染。我们可以用另一种方式来描述 响应丢失问题：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// obj 是响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 将响应式数据展开到一个新的对象 newObj</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> ...obj</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">effect</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 在副作用函数内通过新的对象 newObj 读取 foo 属性值</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">13</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 很显然，此时修改 obj.foo 并不会触发响应</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span></span>
<span class="line"></span></code></pre></div><p>如上面的代码所示，首先创建一个响应式的数据对象 obj，然后 使用展开运算符得到一个新的对象 newObj，它是一个普通对象，不具 有响应能力。这里的关键点在于，副作用函数内访问的是普通对象 newObj，它没有任何响应能力，所以当我们尝试修改 obj.foo 的值 时，不会触发副作用函数重新执行。</p><p>如何解决这个问题呢？换句话说，有没有办法能够帮助我们实 现：在副作用函数内，即使通过普通对象 newObj 来访问属性值，也 能够建立响应联系？其实是可以的，代码如下：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// obj 是响应式数据</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">03</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// newObj 对象下具有与 obj 对象同名的属性，并且每个属性值都是一个对象，</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 该对象具有一个访问器属性 value，当读取 value 的值时，其实读取的是 obj对象下相应的属性值</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> get value</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> return obj.foo</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">12 bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span></span>
<span class="line"><span style="color:#F78C6C;">15</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">16 }</span></span>
<span class="line"><span style="color:#A6ACCD;">17 }</span></span>
<span class="line"><span style="color:#F78C6C;">18</span></span>
<span class="line"><span style="color:#F78C6C;">19</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">effect</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">20</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 在副作用函数内通过新的对象 newObj 读取 foo 属性值</span></span>
<span class="line"><span style="color:#F78C6C;">21</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">console</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">newObj</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">foo</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">value</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">22 })</span></span>
<span class="line"><span style="color:#F78C6C;">23</span></span>
<span class="line"><span style="color:#F78C6C;">24</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 这时能够触发响应了</span></span>
<span class="line"><span style="color:#F78C6C;">25</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">foo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>在上面这段代码中，我们修改了 newObj 对象的实现方式。可以 看到，在现在的 newObj 对象下，具有与 obj 对象同名的属性，而且 每个属性的值都是一个对象，例如 foo 属性的值是：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">get</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">value</span><span style="color:#F07178;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>该对象有一个访问器属性 value，当读取 value 的值时，最终读 取的是响应式数据 obj 下的同名属性值。也就是说，当在副作用函数 内读取 newObj.foo 时，等价于间接读取了 obj.foo 的值。这样响 应式数据自然能够与副作用函数建立响应联系。于是，当我们尝试修 改 obj.foo 的值时，能够触发副作用函数重新执行。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get value</span><span style="color:#A6ACCD;">() {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> return obj.foo</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">07 bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">11 }</span></span>
<span class="line"><span style="color:#A6ACCD;">12 }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>foo 和 bar 这两个属性的结构非常像，这启发我们将这种结构抽 象出来并封装成函数，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get value() {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> return obj[key]</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">07</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> wrapper</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>toRef 函数接收两个参数，第一个参数 obj 是一个响应式数据， 第二个参数是 obj 对象的一个键。该函数会返回一个类似于 ref 结构 的 wrapper 对象。有了 toRef 函数后，我们就可以重新实现 newObj 对象了：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">foo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，代码变得非常简洁。但如果响应式数据 obj 的键非常 多，我们还是要花费很大力气来做这一层转换。为此，我们可以封装 toRefs 函数，来批量地完成转换</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRefs</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ret</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 使用 for...in 循环遍历对象</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">in</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 逐个调用 toRef 完成转换</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ret</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ret</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>现在，我们只需要一步操作即可完成对一个对象的转换：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>可以使用如下代码进行测试：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">02</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"></span></code></pre></div><p>现在，响应丢失问题就被我们彻底解决了。解决问题的思路是， 将响应式数据转换成类似于 ref 结构的数据。但为了概念上的统一， 我们会将通过 toRef 或 toRefs 转换后得到的结果视为真正的 ref 数据，为此我们需要为 toRef 函数增加一段代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get value() {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> return obj[key]</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 定义 __v_isRef 属性</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(wrapper</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">__v_isRef</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">11</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> wrapper</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，我们使用 Object.defineProperty 函数为 wrapper 对象定义了 __v_isRef 属性。这样，toRef 函数的返回值 就是真正意义上的 ref 了。通过上述讲解我们能注意到，ref 的作用 不仅仅是实现原始值的响应式方案，它还用来解决响应丢失问题。 但上文中实现的 toRef 函数存在缺陷，即通过 toRef 函数创建 的 ref 是只读的，如下面的代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">toRef</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">key</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">wrapper</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get value() {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> return obj[key]</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">06 </span><span style="color:#676E95;font-style:italic;">// 允许设置值</span></span>
<span class="line"><span style="color:#F07178;">07 </span><span style="color:#A6ACCD;">set</span><span style="color:#F07178;"> value(val) {</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"><span style="color:#F78C6C;">11</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(wrapper</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">__v_isRef</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">13</span><span style="color:#F07178;"> value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F78C6C;">14</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">15</span></span>
<span class="line"><span style="color:#F78C6C;">16</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> wrapper</span></span>
<span class="line"><span style="color:#F78C6C;">17</span><span style="color:#A6ACCD;"> }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>可以看到，当设置 value 属性的值时，最终设置的是响应式数据 的同名属性的值，这样就能正确地触发响应了。</p><h2 id="_6-3-自动脱-ref" tabindex="-1">6.3 自动脱 ref <a class="header-anchor" href="#_6-3-自动脱-ref" aria-hidden="true">#</a></h2><p>toRefs 函数的确解决了响应丢失问题，但同时也带来了新的问 题。由于 toRefs 会把响应式数据的第一层属性值转换为 ref，因此 必须通过 value 属性访问值，如以下代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#F78C6C;">04</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 必须使用 value 访问值</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#A6ACCD;"> newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#A6ACCD;"> newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"></span></code></pre></div><p>这其实增加了用户的心智负担，因为通常情况下用户是在模板中 访问数据的，例如：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">{ foo </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">} </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#A6ACCD;">p</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>可以看到，即使 newObj.foo 是一个 ref，也无须通过 newObj.foo.value 来访问它的值。要实现此功能，需要使用 Proxy 为 newObj 创建一个代理对象，通过代理来实现最终目标，这 时就用到了上文中介绍的 ref 标识，即 __v_isRef 属性，如下面的 代码所示：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">proxyRefs</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F78C6C;">03</span><span style="color:#F07178;"> get(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> receiver) {</span></span>
<span class="line"><span style="color:#F78C6C;">04</span><span style="color:#F07178;"> const value = Reflect.get(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> receiver)</span></span>
<span class="line"><span style="color:#F78C6C;">05</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 自动脱 ref 实现：如果读取的值是 ref，则返回它的 value 属性值</span></span>
<span class="line"><span style="color:#F78C6C;">06</span><span style="color:#F07178;"> return value.__v_isRef ? value.value </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span></span>
<span class="line"><span style="color:#F78C6C;">07</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">08</span><span style="color:#F07178;"> })</span></span>
<span class="line"><span style="color:#F78C6C;">09</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F78C6C;">10</span></span>
<span class="line"><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 调用 proxyRefs 函数创建代理</span></span>
<span class="line"><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> newObj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">proxyRefs</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#82AAFF;">toRefs</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>在上面这段代码中，我们定义了 proxyRefs 函数，该函数接收 一个对象作为参数，并返回该对象的代理对象。代理对象的作用是拦 截 get 操作，当读取的属性是一个 ref 时，则直接返回该 ref 的 value 属性值，这样就实现了自动脱 ref：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">01</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#F78C6C;">02</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(newObj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bar) </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"></span></code></pre></div><h2 id="_6-4-总结" tabindex="-1">6.4 总结 <a class="header-anchor" href="#_6-4-总结" aria-hidden="true">#</a></h2><ul><li>在本章中，我们首先介绍了 ref 的概念。ref 本质上是一个“包裹 对象”。因为 JavaScript 的 Proxy 无法提供对原始值的代理，所以我们 需要使用一层对象作为包裹，间接实现原始值的响应式方案。由于“包 裹对象”本质上与普通对象没有任何区别，因此为了区分 ref 与普通响 应式对象，我们还为“包裹对象”定义了一个值为 true 的属性，即 __v_isRef，用它作为 ref 的标识。</li><li>ref 除了能够用于原始值的响应式方案之外，还能用来解决响应 丢失问题。为了解决该问题，我们实现了 toRef 以及 toRefs 这两个 函数。它们本质上是对响应式数据做了一层包装，或者叫作“访问代 理”。</li><li>最后，我们讲解了自动脱 ref 的能力。为了减轻用户的心智负 担，我们自动对暴露到模板中的响应式数据进行脱 ref 处理。这样， 用户在模板中使用响应式数据时，就无须关心一个值是不是 ref 了。</li></ul></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-c5936a1e data-v-e033cd21><div class="edit-info" data-v-e033cd21><div class="edit-link" data-v-e033cd21><a class="VPLink link edit-link-button" href="https://github.com/wendaobai/wendaobai.github.io/edit/master/docs/前端框架/vue/5.Vue-响应式-基本类型.md" target="_blank" rel="noreferrer" data-v-e033cd21 data-v-30c06bd3><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-e033cd21><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 更正错误<!--]--><!----></a></div><!----></div><div class="prev-next" data-v-e033cd21><div class="pager" data-v-e033cd21><a class="pager-link prev" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/4.Vue-%E5%93%8D%E5%BA%94%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0.html" data-v-e033cd21><span class="desc" data-v-e033cd21>Previous page</span><span class="title" data-v-e033cd21>4.Vue-响应式-对象实现</span></a></div><div class="has-prev pager" data-v-e033cd21><a class="pager-link next" href="/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/6.Vue-%E6%B8%B2%E6%9F%93%E5%99%A8%E8%AE%BE%E8%AE%A1.html" data-v-e033cd21><span class="desc" data-v-e033cd21>Next page</span><span class="title" data-v-e033cd21>6.Vue-渲染器设计</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter has-sidebar" data-v-93a960b4 data-v-d24360a6><div class="container" data-v-d24360a6><p class="message" data-v-d24360a6>MIT Licensed | Copyright © 2021 - 2022</p><p class="copyright" data-v-d24360a6>粤ICP备2021165391号</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"readme.md\":\"fe108fb5\",\"js_es6_5.箭头函数.md\":\"10535903\",\"js_interview_1.实现new实例化对象.md\":\"a2526dc5\",\"index.md\":\"c328a5fe\",\"前端框架_vue_9.vue-双端diff算法.md\":\"3e2bd12d\",\"js_interview_2.实现call-apply-bind.md\":\"48e00645\",\"js_基础_2.作用域.md\":\"9ae05b72\",\"前端框架_vue_5.vue-响应式-基本类型.md\":\"36628b90\",\"前端运维_nginx.md\":\"2655eadf\",\"前端运维_vim.md\":\"caa96049\",\"js_es6_1.let和const变量声明.md\":\"2db1cb26\",\"前端运维_docker.md\":\"1e5df3c6\",\"前端框架_vue_4.vue-响应式-对象实现.md\":\"4944b88f\",\"前端框架_vue_6.vue-渲染器设计.md\":\"a805e357\",\"前端框架_vue_7.vue-挂载与更新.md\":\"3e748be6\",\"js_interview_4.实现继承.md\":\"4e98b11f\",\"js_基础_3.原型链.md\":\"87817126\",\"前端框架_vue_11.vue-组件实现原理.md\":\"22eaea0c\",\"网络_https.md\":\"897a9b25\",\"前端框架_vue_10.vue-快速diff算法.md\":\"65902b97\",\"网络_tcp.md\":\"5d4a6fd0\",\"js_基础_1.可执行上下文.md\":\"2b45b169\",\"js_interview_3.实现instanceof.md\":\"69d4601e\",\"前端运维_cicd.md\":\"ccded398\",\"网络_http.md\":\"0e56724c\",\"js_es6_3.symbol数据类型.md\":\"90b5355e\",\"前端框架_vue_3.vue-响应式-基础实现.md\":\"596e9ecd\",\"前端运维_linux常见命令.md\":\"c9386942\",\"前端框架_vue_2.vue-框架设计思路.md\":\"3dc7e7a5\",\"前端框架_vue_1.vue-框架设计要素.md\":\"b3f5d151\",\"前端框架_vue_8.vue-简单diff.md\":\"a250cb0c\",\"js_es6_2.set与map数据结构.md\":\"2672f36e\",\"js_es6_4.proxy代理器.md\":\"5cd10aff\"}")</script>
    <script type="module" async src="/assets/app.58766e8b.js"></script>
    
  </body>
</html>